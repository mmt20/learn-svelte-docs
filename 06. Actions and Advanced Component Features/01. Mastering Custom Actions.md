# 01. Mastering Custom Actions and Attachments

This section covers **Actions** (`use:`) and the newer **Attachments** (`@attach`) in Svelte. Both allow you to encapsulate reusable logic and attach it to elements.

---

## üèóÔ∏è Actions (`use:action`)

An action is simply a function that is called when an element is created (mounted to the DOM).

### The Syntax

You apply an action to an element using the `use:` directive:

```svelte
<!-- App.svelte -->
<script>
  function hello(node) {
    console.log('Element mounted:', node);

    return {
      destroy() {
        console.log('Element removed');
      }
    };
  }
</script>

<div use:hello>
  I have an action attached!
</div>
```

### The Action Interface

An action function receives two arguments:
1.  **node**: The DOM element the action is attached to.
2.  **parameters** (optional): Any data passed to the action.

It returns an object (optional) with two methods:
*   `update(parameters)`: Called whenever the parameters change.
*   `destroy()`: Called when the element is removed from the DOM.

**Type Definition (Svelte 5):**

In TypeScript, you can use the `Action` type from `svelte/action`.

```ts
import type { Action } from 'svelte/action';

const myAction: Action<HTMLElement, string> = (node, param) => {
    // ...
    return {
        update(newParam) { /* ... */ },
        destroy() { /* ... */ }
    }
};
```

---

## üñ±Ô∏è Example 1: The Longpress Action (Action)

Let's build a custom `on:longpress` event handler.

```ts
// longpress.svelte.ts
import type { Action } from 'svelte/action';

export const longpress: Action = (node, duration = 500) => {
	let timer: number;

	const handleMousedown = () => {
		timer = setTimeout(() => {
			node.dispatchEvent(new CustomEvent('longpress'));
		}, duration);
	};

	const handleMouseup = () => {
		clearTimeout(timer);
	};

	node.addEventListener('mousedown', handleMousedown);
	node.addEventListener('mouseup', handleMouseup);

	return {
		destroy() {
			node.removeEventListener('mousedown', handleMousedown);
			node.removeEventListener('mouseup', handleMouseup);
		}
	};
};
```

**Usage:**

```svelte
<script>
	import { longpress } from './actions';
</script>

<button use:longpress={1000} onlongpress={() => alert('Long Pressed!')}>
	Press and Hold Me
</button>
```

---

## üõ†Ô∏è Example 2: Tippy.js (Optimized Action)

In Svelte 5, we can leverage `.svelte.ts` files to create actions that use runes like `$effect` for simplified reactivity.

Reference: `src/lib/actions/tippy.svelte.ts`

```ts
import type { Action } from "svelte/action";
import tippy, { type Props } from "tippy.js";
import "tippy.js/dist/tippy.css";

// We accept a "getter" function for options: () => Partial<Props>
const tippyAction: Action<HTMLElement, () => Partial<Props>> = (node, getOptions) => {
  // 1. Initialize the library once
  const tooltip = tippy(node, getOptions());

  // 2. Reactivity: Update props when options change
  $effect(() => {
    tooltip.setProps(getOptions());
  });

  // 3. Cleanup: Destroy on unmount
  return {
    destroy() {
      tooltip.destroy();
    }
  };
};

export default tippyAction;
```

**Usage:**

```svelte
<script lang="ts">
  import tippyAction from "$lib/actions/tippy.svelte";
</script>

<button use:tippyAction={() => ({ content: "Tooltip", animation: "scale" })}>
  Hover Me
</button>
```

---

## üìé Attachments (`@attach`)

> [!NOTE]
> Introduced in **Svelte 5.29**. Attachments are an improved, more flexible version of actions.

Attachments run inside an effect by default and solve the major limitation of actions: **Using them on Components**.

### 1. Attaching to Components (New Feature!)

> [!IMPORTANT]
> **UPDATE:** Unlike the `use:` directive which only works on HTML elements, **Attachments can be applied to Svelte Components**.

This allows you to attach reusable logic (like tooltips or analytics tracking) directly to a component instance, provided the component forwards props to its root element.

```svelte
<script>
    import Button from './Button.svelte'; // A simple component
    import { tooltip } from './attachments';
</script>

<!-- ‚úÖ This WORKS with @attach! (Fails with use:) -->
<Button>
    {@attach tooltip({ content: 'I am a component' })}
    Button Text
</Button>
```

*Note: The `Button` component must spread `...restProps` onto its underlying HTML element for the attachment to bind correctly to the DOM.*

### 2. Basic Syntax & Reactivity

Attachments run **inside an effect**, so they are auto-reactive. You don't need manual `update` methods.

```svelte
<script>
    import tippy from 'tippy.js';

    // Wrapper function to accept arguments
    const tooltip = (options) => {
        // Returns the attachment function
        return (node) => {
            const instance = tippy(node, options);
            
            // Cleanup function
            return () => instance.destroy();
        };
    };

    let msg = $state('Hello');
</script>

<button>
    <!-- Re-runs automatically when `msg` changes -->
    {@attach tooltip({ content: msg })}
    Hover Me
</button>
```

### 3. Inline Attachments

You can define attachments inline, which wasn't possible with actions.

```svelte
<div class="box">
    {@attach (node) => {
        console.log('I am attached to', node);
        return () => console.log('bye');
    }}
</div>
```

---

## ‚öñÔ∏è Comparison: Actions vs. Attachments

| Feature | Actions (`use:`) | Attachments (`@attach`) |
| :--- | :--- | :--- |
| **Target** | HTML Elements only | **HTML Elements & Components** |
| **Reactivity** | Manual (`update` or `$effect`) | **Automatic** (Runs in effect) |
| **Syntax** | Directive (`use:fn`) | Tag (`{@attach fn}`) |

---

## ‚ö†Ô∏è Pitfalls: Attachments

While Attachments are powerful, their auto-reactivity can catch you off guard.

### 1. Infinite Loops (The "Reactive Cycle")

Attachments run inside an implicit `$effect`. This means Svelte automatically tracks any reactive state you read during the attachment's execution.

**The Trap:**
1.  The attachment runs and reads a state variable (e.g., `count`).
2.  Svelte registers `count` as a dependency of this attachment.
3.  The attachment *updates* `count` immediately (e.g., `count++`).
4.  Because `count` changed, Svelte re-runs the attachment.
5.  Go to step 1. -> **Infinite Loop!**

```svelte
<script>
    import { untrack } from 'svelte';
    let count = $state(0);
    
    // BAD ‚ùå: Updates `count`, triggering itself to run again immediately
    const loop = (node) => {
        count += 1; // Reads count (track) -> Writes count (trigger)
    };

    // GOOD ‚úÖ: Use `untrack` to read state without subscribing
    const fixed = (node) => {
         // Update state without tracking it as a dependency
        untrack(() => {
            count += 1;
        });
    };
</script>

{@attach loop} 
```

### 2. Forgetful Cleanup
Just like actions, if you add an event listener in an attachment, you **must** remove it in the returned cleanup function. Attachments re-run whenever their dependencies change, so failing to cleanup will duplicate listeners rapidly.

```svelte
{@attach (node) => {
    const handler = () => console.log('scroll');
    window.addEventListener('scroll', handler);
    
    // MDN: Always return cleanup!
    return () => window.removeEventListener('scroll', handler);
}}
```


## Summary

*   **Actions** (`use:`) give you direct access to DOM elements, making them perfect for **3rd party integrations** and **custom events**.
*   **Attachments** (`@attach`) extend this power to **Components** and provide automatic reactivity via effects.
*   Always return a **cleanup function** (`destroy`) to prevent memory leaks when adding event listeners or initializing libraries.
