# 02. Advanced Elements and Bindings

Svelte gives you declarative control not just over your components, but over the browser environment and media elements as well.

---

## ü™ü Special Elements

Svelte provides strict "special elements" to interact with the global page state.

### `<svelte:window>`
Add event listeners to the `window` object or bind to window properties.

```svelte
<script>
	let scrollY = $state(0);
    let innerWidth = $state(0);

	function handleKeydown(event) {
		if (event.key === 'Escape') {
			console.log('Escape pressed!');
		}
	}
</script>

<svelte:window 
    bind:scrollY 
    bind:innerWidth 
    onkeydown={handleKeydown} 
/>

<p>Window is {innerWidth}px wide and scrolled to {scrollY}px.</p>
```

### `<svelte:document>`
Similar to window, but for the `document`. Useful for events like `visibilitychange`.

```svelte
<svelte:document 
    onvisibilitychange={() => console.log(document.visibilityState)} 
/>
```

### `<svelte:head>`
Inject elements into the `<head>` of your page (title, meta tags, etc.).

```svelte
<svelte:head>
	<title>My App | Home</title>
	<meta name="description" content="This is my cool Svelte app" />
</svelte:head>
```

### `<svelte:body>`
Add event listeners to `document.body`.

```svelte
<svelte:body onmouseenter={() => console.log('Entered body')} />
```

---

## üöß Error Boundaries (`<svelte:boundary>`)

Svelte 5 introduces a built-in error boundary mechanism to catch errors in child components without crashing the entire app.

```svelte
<script>
    import FlakyComponent from './FlakyComponent.svelte';
</script>

<svelte:boundary onerror={(e) => console.error(e)}>
    <FlakyComponent />

    {#snippet failed(error, reset)}
        <div class="error-box">
            <p>Something went wrong: {error.message}</p>
            <button onclick={reset}>Try Again</button>
        </div>
    {/snippet}
</svelte:boundary>
```

*   **Content**: What processes normally.
*   **failed snippet**: What renders if an error occurs.
*   **reset**: A function passed to the failed snippet to re-mount the component.

---

## üìè Binding Dimensions

You can measure any block-level element's dimensions using bindings. These are **read-only**.

*   `bind:clientWidth`
*   `bind:clientHeight`
*   `bind:offsetWidth`
*   `bind:offsetHeight`

```svelte
<script>
	let w = $state(0);
	let h = $state(0);
</script>

<div bind:clientWidth={w} bind:clientHeight={h} class="box">
	Resize me!
</div>

<p>Size: {w} x {h}</p>

<style>
	.box {
		resize: both;
		overflow: auto;
		border: 1px solid red;
		width: 100px;
		height: 100px;
	}
</style>
```

> [!TIP]
> Use bindings sparingly for layout. If you can solve it with CSS, use CSS. Binding causes re-renders when sizes change.

---

## üé• Binding Media Elements

Svelte makes building custom video/audio players incredibly simple by binding directly to media properties.

### Common Bindings
*   `bind:paused` (read/write)
*   `bind:currentTime` (read/write)
*   `bind:duration` (read-only)
*   `bind:volume` (read/write)
*   `bind:muted` (read/write)

### Example: Custom Video Player

```svelte
<script>
	let vid; // reference to element
	let paused = $state(true);
	let currentTime = $state(0);
	let duration = $state(0);
</script>

<video
	bind:this={vid}
	src="video.mp4"
	bind:paused
	bind:currentTime
	bind:duration
></video>

<div class="controls">
    <!-- Play/Pause Toggle -->
	<button onclick={() => paused = !paused}>
		{paused ? 'Play' : 'Pause'}
	</button>

    <!-- Seek Bar -->
	<input
		type="range"
		bind:value={currentTime}
		min="0"
		max={duration}
		step="0.1"
	/>
    
    <span>{currentTime.toFixed(1)} / {duration.toFixed(1)}s</span>
</div>
```

---

## Summary

*   Use **Special Elements** (`<svelte:window>`, etc.) to bind to the global environment declaratively.
*   Use **Binding Dimensions** to get element sizes in logic (e.g., for canvas resizing or charts).
*   Use **Media Bindings** to create robust custom audio/video players without writing manual event listeners.
*   Use **Error Boundaries** to gracefully handle crashes in sub-components.
