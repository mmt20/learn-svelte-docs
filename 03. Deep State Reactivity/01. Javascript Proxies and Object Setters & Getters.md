# Javascript Proxies and Object Setters & Getters

Svelte 5's reactivity system, powered by **Signals**, might feel like magic. You mutate a property, and the UI updates instantly. This "magic" is actually built on standard JavaScript features: **Object Getters/Setters** and **Proxies**.

Understanding these concepts is key to mastering how `$state` works under the hood.

---

## 1. Object Getters and Setters

Before Proxies existed, JavaScript already had a way to intercept property access and assignment via `get` and `set` keywords.

### How they work

Getters and setters allow you to define methods that execute when a property is read or written to, but they look like regular properties from the outside.

```javascript
const user = {
    _name: "Alice",
    get name() {
        console.log("Reading name...");
        return this._name;
    },
    set name(value) {
        console.log(`Updating name to ${value}...`);
        this._name = value;
    }
};

console.log(user.name); // Reading name... -> "Alice"
user.name = "Bob";      // Updating name to Bob...
```

### In Svelte 5

Svelte uses getters and setters primarily for **class properties**. When you use `$state` or `$props` inside a class, Svelte's compiler transforms those properties into getters and setters. This allows Svelte to:
- **Get**: Track which effect is currently running so it can register a dependency.
- **Set**: Trigger an update to all effects that depend on that specific property.

---

## 2. JavaScript Proxies

While getters/setters are great for individual properties, they have limitations: they must be defined upfront, and they don't handle adding/deleting properties well. This is where **Proxies** come in.

### What is a Proxy?

A `Proxy` object allows you to create a "wrapper" around another object. This wrapper can intercept and redefine fundamental operations for that object, such as property lookup, assignment, enumeration, function invocation, etc.

These interceptors are called **traps**.

```javascript
const target = { message: "hello" };

const handler = {
    get(obj, prop) {
        console.log(`Property "${prop}" was accessed`);
        return obj[prop];
    },
    set(obj, prop, value) {
        console.log(`Property "${prop}" set to ${value}`);
        obj[prop] = value;
        return true; // Success
    }
};

const proxy = new Proxy(target, handler);

proxy.message; // Property "message" was accessed
proxy.count = 10; // Property "count" set to 10
```

### Deep Reactivity with Proxies

The real power of Proxies in Svelte 5 is **Deep Reactivity**. When you wrap a plain object or array in `$state`, Svelte creates a Proxy.

```javascript
let user = $state({
    profile: {
        name: "Alice"
    }
});

// Mutating a deeply nested property
user.profile.name = "Bob"; 
```

When you access `user.profile`, the Proxy returns *another* Proxy for the nested `profile` object. This creates a chain of proxies that allows Svelte to track and trigger updates at any depth without you ever having to manually reassign the top-level object.

---

## 3. Comparing the Two

| Feature | Getters / Setters | Proxies |
| :--- | :--- | :--- |
| **Object Type** | Ideal for Classes | Ideal for Plain Objects/Arrays |
| **Dynamic Properties** | No (must be predefined) | Yes (intercepts any property) |
| **Deletion** | Hard to intercept | Easy (`deleteProperty` trap) |
| **Nesting** | Manual implementation | Can be recursive (Deep Reactivity) |

---

## 4. Why This Matters for Performance

Because Svelte knows *exactly* which property was accessed (via a getter or a proxy trap), it achieves **Fine-grained Reactivity**.

Instead of re-running an entire component or checking a whole object for changes, Svelte knows that "only the `name` property of `user` changed." It then only updates the specific DOM nodes that use that exact value.

> [!IMPORTANT]
> This is why Svelte 5 feels so fast and doesn't suffer from the "over-rendering" issues common in VDOM-based frameworks.

---

## 5. Summary

- **Getters/Setters** are used for tracking individual properties, especially in classes.
- **Proxies** are used to provide deep reactivity for objects and arrays, allowing you to mutate nested data naturally.
- Together, they form the backbone of the **Signal** system, making your code more intuitive and efficient.
