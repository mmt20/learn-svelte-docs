# Debugging in Svelte 5

Debugging in Svelte 5 is significantly more powerful thanks to the move to signals. Because reactivity is now explicit, we have better tools to track exactly **what** changed and **why**.

---

## 1. The `$inspect` Rune

In Svelte 4, you might have used `console.log` or the `{@debug ...}` tag. In Svelte 5, the primary tool for debugging reactivity is the `$inspect` rune.

### why use `$inspect`?
Unlike `console.log`, which only prints a value once, `$inspect` **tracks the signal**. It will automatically re-run and log to the console every time the value it's watching changes.

```js
<script>
  let count = $state(0);
  let user = $state({ name: 'Mostafa' });

  // This will log every time 'count' or 'user.name' changes
  $inspect(count, user.name);
</script>

<button onclick={() => count++}>Increment</button>
```

### Custom Logging with `.with()`
You can pass a callback to `$inspect` using the `.with` method. This is useful for adding custom labels or triggering breakpoints.

```js
$inspect(user).with((type, value) => {
  if (type === 'update') {
    console.log('User was updated:', value);
    // debugger; // You can even trigger the browser debugger here
  }
});
```
- `type`: Either `'init'` (first run) or `'update'`.
- `value`: The current value of the state.

---

## 2. Debugging with `$effect`

While `$inspect` is preferred for simple logging, `$effect` is useful when you need to debug **complex interactions** or side effects.

```js
$effect(() => {
  console.log("Effect triggered by:", someState);
  
  // Useful for tracking if an effect is running too often
  console.count("Effect Execution Count");
});
```

> [!TIP]
> Use `$inspect` for "What is the value right now?".
> Use `$effect` for "What logic is running as a result of this change?".

---

## 3. Dealing with Proxies in the Console

Because Svelte 5 uses JavaScript Proxies for deep reactivity, when you `console.log` an object, you'll see a `Proxy` object in the DevTools.

### How to see the raw data:
1. **Unwrap in code**: Use `JSON.parse(JSON.stringify(obj))` (slow, but works for simple objects).
2. **Browser DevTools**: Most modern browsers (Chrome/Edge/Firefox) have a "Formatters" option or allow you to expand the `[[Target]]` property of a Proxy to see the real data.
3. **Svelte DevTools**: The official Svelte DevTools extension automatically unwraps these for you.

---

## 4. Common Debugging Pitfalls

### The "Infinite Loop"
This happens when an effect modifies a state that it also reads.

```js
// âŒ DANGEROUS: Infinite Loop
$effect(() => {
  count++; // Writing to 'count'
  console.log(count); // Reading 'count'
});
```

**The Fix**: Use `untrack` if you need to read a value without subscribing to it.

```js
import { untrack } from 'svelte';

$effect(() => {
  const currentCount = untrack(() => count);
  console.log("I ran, but I won't re-run just because 'count' changed:", currentCount);
});
```

---

## 6. Summary Table

| Technique | When to Use |
| :--- | :--- |
| **`$inspect(data)`** | Quick, automatic logging of reactive values. |
| **`$inspect.trace()`** | Finding the origin of a re-run (stack trace). |
| **`$state.snapshot()`** | Getting raw, non-reactive data (removing Proxies). |
| **`{@debug}`** | Triggering breakpoints directly in the HTML. |
| **`$effect()`** | Debugging complex side-effect chains. |
| **`untrack(() => ...)`** | Preventing infinite loops during debugging. |

---

## 6. Key Takeaways

- **`$inspect` is your best friend**: It's built-in, reactive, and cleaner than standard logs.
- **Proxies are transparent**: Don't let the `Proxy` wrapper in the console scare you; it's just how Svelte tracks changes.
- **Fine-grained is easier to debug**: Because only specific effects run, you can isolate bugs more easily by looking at which log triggers.

> [!IMPORTANT]
> Remember that `$inspect` only works in **development mode**. It is automatically stripped out in production builds for performance.
