# Deep State Reactivity in Svelte 5

In Svelte 5, `$state` provides **deep reactivity** out of the box. This means you can mutate nested properties of objects and arrays, and Svelte will automatically track those changes and update the UI.

---

## 1. What is Fine-Grained Reactivity?

In many frameworks, when state changes, the entire component (or even the entire app) needs to re-evaluate to figure out what changed. This is **coarse-grained reactivity**.

**Fine-grained reactivity** is different. The framework knows *exactly* which piece of data changed and *exactly* which parts of the UI depend on it. Only those specific parts update.

### Coarse-Grained vs Fine-Grained

| Approach | What Happens on Change |
| :--- | :--- |
| **Coarse-grained** (React, Vue) | Re-runs the entire component function, diffs the virtual DOM |
| **Fine-grained** (Svelte 5, Solid) | Updates only the exact DOM nodes that use the changed value |

### A Simple Analogy

Imagine you have a spreadsheet with 1000 cells. You change the value in cell A1.

- **Coarse-grained**: The entire spreadsheet recalculates all 1000 cells to check if anything depends on A1.
- **Fine-grained**: Only the cells that have a formula referencing A1 recalculate.

This is why Svelte 5 apps can feel incredibly fast ‚Äî there's no wasted work.

---

## 2. How Svelte 5 Achieves This

When you wrap an object or array with `$state`, Svelte uses **JavaScript Proxies** to intercept access and mutations at any depth.

When an `$effect` or a template expression runs, Svelte records exactly which properties were accessed. Later, when a property changes, Svelte knows exactly which effects and DOM nodes need to update.

---

## 3. Practical Example: User Profile Editor

Let's build a realistic example: a user profile editor with nested data.

### Setting Up the State

```js
let user = $state({
  firstName: "Mostafa",
  lastName: "Mohamed",
  email: "mostafa@example.com",
  address: {
    city: "Minya",
    street: "Dermawas",
    country: "Egypt"
  },
  preferences: {
    darkMode: true,
    notifications: false
  }
});

let tags = $state(["developer", "svelte", "typescript"]);
```

We have:
- A **nested object** (`user`) with `address` and `preferences` sub-objects
- An **array** (`tags`) for user tags

---

### Effect: Tracking the Entire User

```js
$effect(() => {
  console.log("üì¶ Full user object changed");
  console.log(user);
});
```

This effect reads the entire `user` object. It will run whenever **ANY** property changes ‚Äî including deeply nested ones like `user.address.city`.

> [!WARNING]
> Avoid reading entire objects in effects unless necessary. This creates broad dependencies and defeats the purpose of fine-grained reactivity.

---

### Effect: Tracking Only the Full Name

```js
$effect(() => {
  console.log("üë§ Name changed:", user.firstName, user.lastName);
});
```

This effect only accesses `firstName` and `lastName`. It will **NOT** run when:
- `user.email` changes
- `user.address.city` changes
- `user.preferences.darkMode` changes

It **ONLY** runs when `firstName` or `lastName` change.

---

### Effect: Tracking a Nested Property

```js
$effect(() => {
  console.log("üèôÔ∏è City changed:", user.address.city);
});
```

Deep reactivity shines here. This effect tracks `user.address.city` specifically. Changing `user.address.street` or `user.address.country` will **NOT** trigger it.

---

### Effect: Tracking Array Changes

```js
$effect(() => {
  console.log("üè∑Ô∏è First tag:", tags[0]);
});

$effect(() => {
  console.log("üìä Total tags:", tags.length);
});
```

- The first effect only runs when `tags[0]` changes
- The second effect only runs when the array length changes (push, pop, splice)

Modifying `tags[1]` will NOT trigger either of these effects!

---

### The Template

```svelte
<div class="profile-editor">
  <h2>{user.firstName} {user.lastName}</h2>
  <p>üìç {user.address.city}, {user.address.country}</p>
  
  <section>
    <h3>Basic Info</h3>
    <input bind:value={user.firstName} placeholder="First Name" />
    <input bind:value={user.lastName} placeholder="Last Name" />
    <input bind:value={user.email} placeholder="Email" />
  </section>
  
  <section>
    <h3>Address</h3>
    <input bind:value={user.address.city} placeholder="City" />
    <input bind:value={user.address.street} placeholder="Street" />
    <input bind:value={user.address.country} placeholder="Country" />
  </section>
  
  <section>
    <h3>Tags</h3>
    <p>{tags.join(", ")}</p>
    <button onclick={() => tags.push("new-tag")}>Add Tag</button>
    <button onclick={() => tags[0] = "modified"}>Modify First Tag</button>
  </section>
</div>
```

### What's happening:
1. **Two-way binding**: `bind:value` syncs the input with the state. Type in the input ‚Üí state updates ‚Üí UI updates.
2. **Direct mutation**: `tags.push()` and `tags[0] = ...` work directly. No need to clone or reassign!
3. **Surgical updates**: Only the specific `<h2>` or `<p>` that uses the changed data will update in the DOM.

---

## 4. Two-Way Binding with `$bindable()`

In Svelte 5, you can create **bindable props** that allow a child component to update values in the parent. This is done using the `$bindable()` rune.

### Why Use `$bindable()`?

When you pass a prop to a child component, it's normally **one-way**: the parent sends data down, but the child can't modify it. With `$bindable()`, you explicitly mark a prop as **two-way bindable**, allowing the child to update the parent's state.

### Example: Volume Control Component

Let's create a reusable volume slider that can update the parent's volume state.

**VolumeSlider.svelte (Child Component)**

```js
<script>
  // The 'volume' prop is bindable, meaning the parent can bind to it
  let { volume = $bindable(50) } = $props();
</script>

<div class="volume-control">
  <label>Volume: {volume}%</label>
  <input 
    type="range" 
    bind:value={volume} 
    min="0" 
    max="100" 
  />
</div>
```

**App.svelte (Parent Component)**

```js
<script>
  import VolumeSlider from './VolumeSlider.svelte';
  
  let audioVolume = $state(75);
  
  $effect(() => {
    console.log("üîä Volume changed to:", audioVolume);
  });
</script>

<h1>Audio Player</h1>
<p>Current Volume: {audioVolume}%</p>

<!-- Two-way binding: changes in VolumeSlider update audioVolume -->
<VolumeSlider bind:volume={audioVolume} />

<button onclick={() => audioVolume = 100}>Max Volume</button>
<button onclick={() => audioVolume = 0}>Mute</button>
```

### How It Works

1. **Child declares bindable**: `let { volume = $bindable(50) } = $props();`
   - The `50` is the default value if no binding is provided
2. **Parent binds to it**: `<VolumeSlider bind:volume={audioVolume} />`
   - The `bind:` directive creates a two-way connection
3. **Changes flow both ways**:
   - When the slider moves ‚Üí `volume` updates ‚Üí `audioVolume` updates in parent
   - When parent clicks "Max Volume" ‚Üí `audioVolume` changes ‚Üí `volume` updates in child

> [!IMPORTANT]
> The `$bindable()` rune makes the contract explicit: "This prop can be mutated by the child component." This is clearer than Svelte 4's implicit two-way binding.

### Bindable with Nested Objects

You can also bind to nested properties:

**UserForm.svelte (Child)**

```js
<script>
  let { user = $bindable({ name: '', email: '' }) } = $props();
</script>

<input bind:value={user.name} placeholder="Name" />
<input bind:value={user.email} placeholder="Email" />
```

**App.svelte (Parent)**

```js
<script>
  let currentUser = $state({ name: 'Mostafa', email: 'mostafa@example.com' });
</script>

<UserForm bind:user={currentUser} />
<p>User: {currentUser.name} ({currentUser.email})</p>
```

Because `$state` provides deep reactivity, changes to `user.name` or `user.email` in the child will automatically update `currentUser` in the parent!

---

## 5. Experiment: Understanding Fine-Grained Reactivity

To truly understand how fine-grained reactivity works, try these experiments in your browser console:

### Experiment 1: Property-Level Tracking
1. **Change `firstName`** in the input
   - ‚úÖ Logs: "üì¶ Full user object changed" (reads entire object)
   - ‚úÖ Logs: "üë§ Name changed" (reads firstName)
   - ‚ùå Does NOT log: "üèôÔ∏è City changed" (doesn't read city)

2. **Change `city`** in the input
   - ‚úÖ Logs: "üì¶ Full user object changed" (reads entire object)
   - ‚úÖ Logs: "üèôÔ∏è City changed" (reads city)
   - ‚ùå Does NOT log: "üë§ Name changed" (doesn't read firstName)

### Experiment 2: Array Reactivity
3. **Click "Add Tag"** (uses `tags.push()`)
   - ‚úÖ Logs: "üìä Total tags" (tracks length)
   - ‚ùå Does NOT log: "üè∑Ô∏è First tag" (first element unchanged)

4. **Click "Modify First Tag"** (changes `tags[0]`)
   - ‚úÖ Logs: "üè∑Ô∏è First tag" (tracks tags[0])
   - ‚ùå Does NOT log: "üìä Total tags" (length unchanged)

### What This Teaches You
- **Precision**: Svelte knows *exactly* which property changed
- **Efficiency**: Only relevant code runs, nothing else
- **Predictability**: You can trace exactly why an effect ran

> [!TIP]
> Open your browser's DevTools console (F12) and watch the logs as you interact. This builds intuition for how dependencies work.

---

## 6. Summary Table

| What You Track | Effect Runs When | Example Triggers |
| :--- | :--- | :--- |
| `user` (entire object) | Any property changes (including nested) | `user.firstName = 'Ali'`, `user.address.city = 'Cairo'` |
| `user.firstName` | Only `firstName` changes | `user.firstName = 'Ali'` |
| `user.address.city` | Only `city` inside `address` changes | `user.address.city = 'Cairo'` |
| `user.address` (sub-object) | Any property in `address` changes | `user.address.city = 'Cairo'`, `user.address.street = 'Main'` |
| `tags[0]` | Only the first element changes | `tags[0] = 'new'` |
| `tags.length` | Array size changes | `tags.push()`, `tags.pop()`, `tags.splice()` |
| `tags` (entire array) | Any element or length changes | `tags[0] = 'new'`, `tags.push('item')` |

---

## 7. Key Takeaways

### ‚úÖ What Makes Svelte 5 Different
- **Fine-grained reactivity**: Svelte tracks exactly which properties you access and only updates what's needed, not the entire component.
- **Direct mutations work**: Unlike Svelte 4, you don't need `user = { ...user }` to trigger updates. Just mutate directly: `user.name = 'Ali'`.
- **Deep reactivity by default**: Nested objects and arrays are automatically tracked at any level through JavaScript Proxies.
- **Two-way binding with `$bindable()`**: Child components can update parent state explicitly and safely.

### ‚ö†Ô∏è Best Practices
- **Be specific with dependencies**: Reading an entire object (`$effect(() => console.log(user))`) creates broad dependencies. Access specific properties when possible.
- **Use `$bindable()` intentionally**: Only mark props as bindable when you actually need two-way communication.
- **Watch for infinite loops**: Don't write to state you're reading in the same effect without using `untrack()`.

### üéØ Performance Benefits
- **No virtual DOM diffing**: Svelte updates only the exact DOM nodes that need to change.
- **Smaller bundle sizes**: Less framework code means faster load times.
- **Predictable updates**: You can trace exactly which state change caused which effect to run.

> [!TIP]
> The best way to learn fine-grained reactivity is to experiment! Open your browser console, add `$effect()` blocks, and watch what triggers when.
