# 02. Fundamentals of SvelteKit

SvelteKit is the official application framework for Svelte. It provides everything you need to build production-ready web applications: routing, server-side rendering, data loading, and more.

---

## ğŸ¤” Why SvelteKit?

| Feature | Benefit |
| :--- | :--- |
| **File-based routing** | No router configuration needed |
| **Server-side rendering** | Better performance and SEO |
| **Hybrid rendering** | SSR, CSR, SSG, all in one project |
| **Built-in data loading** | Colocated `load` functions |
| **API routes** | Backend endpoints alongside pages |
| **Adapters** | Deploy anywhere (Node, Vercel, Cloudflare, etc.) |

---

## ğŸš€ Creating a New Project

```bash
# Create a new SvelteKit project
npx sv create my-app

# Navigate to the project
cd my-app

# Install dependencies
npm install

# Start the dev server
npm run dev
```

> [!TIP]
> The `sv create` wizard lets you choose between TypeScript/JavaScript, add ESLint, Prettier, and more.

---

## ğŸ“ Project Structure

A typical SvelteKit project looks like this:

```
my-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib/              # Shared components, utilities, stores
â”‚   â”‚   â””â”€â”€ components/   # Reusable Svelte components
â”‚   â”œâ”€â”€ routes/           # File-based routing (pages + layouts)
â”‚   â”‚   â”œâ”€â”€ +page.svelte  # Home page (/)
â”‚   â”‚   â””â”€â”€ about/
â”‚   â”‚       â””â”€â”€ +page.svelte  # About page (/about)
â”‚   â”œâ”€â”€ app.html          # HTML template
â”‚   â”œâ”€â”€ app.d.ts          # TypeScript definitions (locals, errors, etc.)
â”‚   â””â”€â”€ app.css           # Global styles (optional)
â”œâ”€â”€ static/               # Static assets (favicon, images, etc.)
â”œâ”€â”€ svelte.config.js      # SvelteKit configuration
â”œâ”€â”€ vite.config.js        # Vite configuration
â””â”€â”€ package.json
```

### Key Directories

| Directory | Purpose |
| :--- | :--- |
| `src/routes/` | All pages, layouts, and API endpoints |
| `src/lib/` | Shared code (aliased as `$lib`) |
| `static/` | Static files served at root (e.g., `/favicon.png`) |

---

## ğŸ—ï¸ Project Architecture Patterns

There are two common ways to organize your `src/lib/` folder: **Type-Based** and **Feature-Based**.

### Type-Based Architecture (Traditional)

Organize files by **what they are** (components, stores, utils, etc.):

```
src/lib/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Button.svelte
â”‚   â”œâ”€â”€ Modal.svelte
â”‚   â”œâ”€â”€ TodoItem.svelte
â”‚   â””â”€â”€ UserAvatar.svelte
â”œâ”€â”€ stores/
â”‚   â”œâ”€â”€ auth.svelte.ts
â”‚   â”œâ”€â”€ todos.svelte.ts
â”‚   â””â”€â”€ theme.svelte.ts
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ api.ts
â”‚   â”œâ”€â”€ formatDate.ts
â”‚   â””â”€â”€ validation.ts
â”œâ”€â”€ types/
â”‚   â”œâ”€â”€ user.ts
â”‚   â””â”€â”€ todo.ts
â””â”€â”€ services/
    â”œâ”€â”€ authService.ts
    â””â”€â”€ todoService.ts
```

**Pros:**
-   Simple and familiar
-   Easy to find files by type
-   Good for small to medium projects

**Cons:**
-   Related files scattered across folders
-   Hard to see feature boundaries
-   Difficult to extract or delete features

---

### Feature-Based Architecture (Recommended for Large Apps)

Organize files by **feature/domain** they belong to:

```
src/lib/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginForm.svelte
â”‚   â”‚   â”‚   â””â”€â”€ SignupForm.svelte
â”‚   â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”‚   â””â”€â”€ auth.svelte.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ authService.ts
â”‚   â”‚   â”œâ”€â”€ types.ts
â”‚   â”‚   â””â”€â”€ index.ts          # Public API (barrel export)
â”‚   â”‚
â”‚   â”œâ”€â”€ todos/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ TodoList.svelte
â”‚   â”‚   â”‚   â”œâ”€â”€ TodoItem.svelte
â”‚   â”‚   â”‚   â””â”€â”€ AddTodo.svelte
â”‚   â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”‚   â””â”€â”€ todos.svelte.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ todoService.ts
â”‚   â”‚   â”œâ”€â”€ types.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â””â”€â”€ settings/
â”‚       â”œâ”€â”€ components/
â”‚       â”‚   â””â”€â”€ SettingsForm.svelte
â”‚       â”œâ”€â”€ stores/
â”‚       â”‚   â””â”€â”€ settings.svelte.ts
â”‚       â””â”€â”€ index.ts
â”‚
â””â”€â”€ shared/                   # Cross-feature shared code
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ Button.svelte
    â”‚   â”œâ”€â”€ Modal.svelte
    â”‚   â””â”€â”€ Input.svelte
    â”œâ”€â”€ utils/
    â”‚   â””â”€â”€ formatDate.ts
    â””â”€â”€ types/
        â””â”€â”€ common.ts
```

**Pros:**
-   All related code in one place
-   Easy to add, remove, or refactor features
-   Clear boundaries between domains
-   Scales well for large applications
-   Easier team collaboration (each team owns a feature)

**Cons:**
-   More initial setup
-   May have some duplication

---

### Barrel Exports (`index.ts`)

Use barrel exports to create a clean public API for each feature:

```typescript
// src/lib/features/todos/index.ts
export { default as TodoList } from './components/TodoList.svelte';
export { default as TodoItem } from './components/TodoItem.svelte';
export { todoStore } from './stores/todos.svelte';
export type { Todo } from './types';
```

```svelte
<!-- Usage in routes -->
<script>
  import { TodoList, todoStore } from '$lib/features/todos';
</script>
```

> [!TIP]
> Barrel exports hide internal implementation details and make refactoring easier.

---

### Connecting Features to Routes (The Glue Layer)

In a feature-based architecture, your **routes serve as a thin "glue" layer**. They shouldn't contain heavy logic; instead, they import and orchestrate features from `$lib`.

**File: `src/routes/todos/+page.svelte`**

```svelte
<script>
  import { TodoList, AddTodo } from '$lib/features/todos';
</script>

<h1>My Todos</h1>

<AddTodo />
<TodoList />
```

**File: `src/routes/todos/+page.server.js`**

```javascript
import { todoService } from '$lib/features/todos/services';

export async function load({ locals }) {
  const todos = await todoService.getTodos(locals.user.id);
  return { todos };
}

export const actions = {
  add: async ({ request, locals }) => {
    const data = await request.formData();
    await todoService.add(locals.user.id, data.get('text'));
  }
};
```

**Benefits of thin routes:**
1.  **Testability**: You can unit test your features in isolation without mocking the entire SvelteKit routing context.
2.  **Portability**: It's easier to move features to different routes or even different projects.
3.  **Refactoring**: Changing a URL structure doesn't require rewriting your business logic.

---

### Hybrid Approach

Many projects use a **hybrid** approachâ€”type-based for small shared utilities and feature-based for core domain logic:

```
src/lib/
â”œâ”€â”€ components/           # Global shared UI components
â”‚   â”œâ”€â”€ Button.svelte
â”‚   â””â”€â”€ Modal.svelte
â”œâ”€â”€ utils/                # Global utilities
â”‚   â””â”€â”€ formatDate.ts
â”œâ”€â”€ features/             # Feature modules
â”‚   â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ todos/
â”‚   â””â”€â”€ settings/
â””â”€â”€ server/               # Server-only code
    â””â”€â”€ database.ts
```

---

### Which Architecture to Choose?

| Project Size | Recommendation |
| :--- | :--- |
| **Small** (1-5 pages) | Type-based is fine |
| **Medium** (5-15 pages) | Consider hybrid approach |
| **Large** (15+ pages, multiple devs) | Feature-based strongly recommended |

> [!IMPORTANT]
> The key principle: **code that changes together should live together**.


---

## âš›ï¸ SvelteKit for Next.js Developers

If you're coming from **Next.js (App Router)**, here is how common architectural patterns translate to SvelteKit.

### 1. Server Components vs. `+page.server.js`

In Next.js, `page.tsx` is a Server Component by default where you fetch data. In SvelteKit, we separate the logic from the view.

| Next.js (App Router) | SvelteKit Equivalent |
| :--- | :--- |
| **`page.tsx` (RSC)** | **`+page.server.js`** (Load function) |
| Async data fetching inside component | `export async function load()` |
| **`'use client'`** components | Standard `.svelte` components (Isomorphic) |

**Comparison:**

*   **Next.js:** You fetch data directly inside the async `page.tsx` component.
*   **SvelteKit:** You fetch data in `load` (`+page.server.js`), and pass it to `+page.svelte` via `data` prop. `+page.svelte` is rendered on the server (SSR) and hydrated on the client.

### 2. Server Actions vs. Form Actions

| Next.js | SvelteKit |
| :--- | :--- |
| **Server Actions** (`"use server"`) | **Form Actions** (`export const actions`) |
| `useFormState` / `useFormStatus` | `use:enhance` / `page.form` property |
| `revalidatePath()` | `invalidate()` / `invalidateAll()` |

**Example: Mutation Flow**

**Next.js:**
```tsx
// actions.ts
'use server'
export async function create(formData) { ... }

// Component.tsx
<form action={create}>...</form>
```

**SvelteKit:**
```javascript
// +page.server.js
export const actions = {
  default: async ({ request }) => { ... }
};
```
```svelte
<!-- +page.svelte -->
<form method="POST" use:enhance>...</form>
```

### 3. `useTransition` & `useForm` vs. `use:enhance`

In Next.js, you often use `useTransition` to handle pending UI or libraries like React Hook Form.

SvelteKit has **Progressive Enhancement** built-in via `use:enhance`.

```svelte
<script>
  import { enhance } from '$app/forms';
  
  let creating = $state(false);
</script>

<form
  method="POST"
  use:enhance={() => {
    creating = true; // "Optimistic UI" start
    
    return async ({ update }) => {
      await update();
      creating = false; // Cleanup
    };
  }}
>
  <button disabled={creating}>
    {creating ? 'Saving...' : 'Save'}
  </button>
</form>
```

*   **No manual `fetch` calls needed.**
*   **No complex state management** for simple mutations.
*   **Works without JS** by default (if you remove `use:enhance`, it falls back to native browser form submission).

### 4. React Query vs. `load` functions

| Next.js Pattern | SvelteKit Pattern |
| :--- | :--- |
| **React Query** (Client-side fetch) | **`+page.js` `load`** (Universal Load) |
| `useQuery` | `export function load({ fetch })` |

In SvelteKit, the `load` function in `+page.js` runs on the server (SSR) AND the client (hydration/navigation). This replaces the need for React Query for simple data fetching, as SvelteKit handles the "fetching" lifecycle during navigation.

> [!TIP]
> You can still use **TanStack Query (Svelte Query)** if you have complex caching/deduplication needs, but start with standard `load` functions first.

---

## ğŸ“¦ The `$lib` Alias

Everything inside `src/lib/` can be imported using the `$lib` alias:

```svelte
<script>
  import Button from '$lib/components/Button.svelte';
  import { formatDate } from '$lib/utils.js';
</script>
```

> [!TIP]
> Use `$lib` to avoid messy relative imports like `../../../lib/components`.

---

## âš™ï¸ Configuration Files

### `svelte.config.js`

The main configuration file for SvelteKit:

```javascript
import adapter from '@sveltejs/adapter-auto';

export default {
  kit: {
    adapter: adapter(),
    // Other options...
  }
};
```

### Common Configuration Options

| Option | Description |
| :--- | :--- |
| `adapter` | Deployment target (Node, Vercel, Cloudflare, etc.) |
| `alias` | Custom import aliases |
| `paths.base` | Base path for your app (e.g., `/my-app`) |
| `prerender` | Global prerender settings |

### `vite.config.js`

SvelteKit uses Vite as its build tool:

```javascript
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [sveltekit()]
});
```

---

## ğŸ› ï¸ Development Commands

| Command | Description |
| :--- | :--- |
| `npm run dev` | Start development server with hot reload |
| `npm run build` | Build for production |
| `npm run preview` | Preview production build locally |

### Development Server

```bash
npm run dev

# With network access (for testing on other devices)
npm run dev -- --host
```

The dev server provides:
-   Hot module replacement (HMR)
-   Fast refresh on file changes
-   Error overlay with helpful messages

---

## ğŸ  The HTML Template (`app.html`)

The `src/app.html` file is the shell for your application:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover">
    <div style="display: contents">%sveltekit.body%</div>
  </body>
</html>
```

### Template Placeholders

| Placeholder | Replaced With |
| :--- | :--- |
| `%sveltekit.head%` | `<link>`, `<script>`, `<svelte:head>` content |
| `%sveltekit.body%` | Rendered page content |
| `%sveltekit.assets%` | Path to static assets |

---

## ğŸ” Environment Variables

SvelteKit offers type-safe access to environment variables, split into **Public/Private** and **Static/Dynamic**.

### 1. Static vs. Dynamic

*   **Static** (`$env/static/...`): Inlined at **build time**. Use for constants that won't change after deployment (e.g., API keys, build flags).
*   **Dynamic** (`$env/dynamic/...`): Read at **runtime**. Use for values that might change between environments without rebuilding (e.g., database URLs in Docker containers).

### 2. Public vs. Private

#### Public (Client + Server)
Prefixed with `PUBLIC_` (configurable). Safe to expose to the browser.

```bash
# .env
PUBLIC_ANALYTICS_ID=UA-123456
```

```javascript
import { PUBLIC_ANALYTICS_ID } from '$env/static/public';
```

#### Private (Server Only)
Everything else. **Cannot** be imported into client-side code.

```bash
# .env
DATABASE_URL=postgres://user:pass@localhost:5432
API_SECRET=sk_live_...
```

```javascript
// +page.server.js
import { DATABASE_URL } from '$env/static/private';
// OR for runtime values:
import { env } from '$env/dynamic/private'; 
```

> [!CAUTION]
> SvelteKit prevents you from importing private modules into client code to avoid accidental credential leaks.

---

## ğŸ”Œ Adapters

Adapters customize SvelteKit's output for different deployment platforms:

| Adapter | Platform |
| :--- | :--- |
| `adapter-auto` | Auto-detects platform (default) |
| `adapter-node` | Node.js server |
| `adapter-static` | Static site generation |
| `adapter-vercel` | Vercel |
| `adapter-cloudflare` | Cloudflare Workers/Pages |
| `adapter-netlify` | Netlify |

```javascript
// svelte.config.js
import adapter from '@sveltejs/adapter-node';

export default {
  kit: {
    adapter: adapter()
  }
};
```

---

## ğŸ“Š Summary

| Concept | Key Point |
| :--- | :--- |
| **Project Structure** | Routes in `src/routes/`, shared code in `src/lib/` |
| **Configuration** | `svelte.config.js` for SvelteKit, `vite.config.js` for Vite |
| **Development** | `npm run dev` with HMR |
| **Build** | `npm run build` then `npm run preview` |
| **Adapters** | Choose based on deployment target |
| **Environment** | `PUBLIC_*` for client, private for server only |

---

**Next Up**: [Routing and Layouts](./03.%20Routing%20and%20Layouts.md) â†’
