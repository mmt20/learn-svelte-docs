# Context vs Universal Reactivity

Svelte 5 offers two ways to share state: **Global Modules** (Universal Reactivity) and **Scoped Propagation** (Context API). Choosing the wrong one can lead to server-side data leaks or architectural rigidity.

---

## 1. When to use what?

| Feature | Universal Reactivity (Modules) | Context API |
| :--- | :--- | :--- |
| **Scope** | App-wide (Singleton) | Component Tree-wide (Scoped) |
| **Instantiation** | Once (per app session) | Once (per component instance) |
| **Access** | Anywhere | Only in descendants of a provider |
| **SSR Safety** | âš ï¸ Use with care | âœ… Native & Safe |

---

## 2. The Singleton Pitfall (Module 04 Recap)

Using a `.svelte.ts` file to export a `$state` object is perfect for **global** state like:
-   Current user session
-   Global theme settings
-   Application-wide notification queues

However, it fails for **reusable components**. If you build a `Tabs` component that stores its active index in a global module, **all** instances of `Tabs` on your page will switch tabs simultaneously because they share the same singleton state.

### âœ… The Context Solution
Context allows each `Tabs` instance to create its own independent state and share it only with its specific children.

---

## 3. Server-Side Rendering (SSR) Safety

The most technical pitfall in Svelte development is **cross-request state leaks**.

### ğŸš¨ The Module Leak (DANGER)
When you export a stateful object from a module:
```javascript
// store.svelte.ts
export const sharedCount = $state({ value: 0 });
```
In a Node.js server, this module is loaded **once** and stays in memory. If User A visits your site and increments `sharedCount`, User B (visiting from a different computer) will see the count already incremented. **Data is shared between users.**

### âœ… The Context Solution
Context is created during component initialization. Since each request creates a new component tree instance, Context state is naturally isolated to the current request.

> [!CAUTION]
> **Never** use global modules for user-specific data (like tokens, names, or shopping carts) if your app uses SSR. Always use Context.

---

## 4. Pattern Comparison: Stores vs Context

In previous Svelte versions, "Svelte Stores" were often used inside Context. In Svelte 5, we prefer passing objects with runes.

### The Modern Svelte 5 Architecture
1.  **Define Logic**: Create a class or function in a `.svelte.ts` file (Sharing Logic).
2.  **Initialize**: Call that logic inside a parent component (`setContext`).
3.  **Consume**: Use `getContext` in children to access that specific instance.

This gives you the benefits of **reusable logic** (Module 04) combined with **isolated state** (Module 05).

---

## 5. Decision Tree

Ask yourself these questions when starting a new feature:

1.  **Is there only ever ONE of these?** (e.g., a "current user")
    *   *Yes* -> Global Module (`.svelte.ts`)
2.  **Does this data belong ONLY to this specific part of the UI?**
    *   *Yes* -> Context API
3.  **Does the data need to be fresh for every browser tab/user?**
    *   *Yes* -> Context API (for SSR) or Global Module (Client-only)
4.  **Am I building a library for others?**
    *   *Yes* -> **Always** use Context to avoid state collisions.

---

## ğŸ Module Conclusion

Congratulations! You now master the two pillars of state distribution in Svelte 5.
-   **Module 04** taught you how to share logic and global state via modules.
-   **Module 05** taught you how to bridge the component gap using scoped context.

By combining these, you can architect massive, performant, and type-safe applications that scale. ğŸš€
