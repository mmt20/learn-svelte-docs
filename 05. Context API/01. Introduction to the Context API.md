# Introduction to the Context API

The Context API is Svelte's mechanism for sharing state and logic between components without passing props through every intermediate level (prop drilling). It is specifically designed for **scoped** data communication within a component tree.

---

## 1. Introduction to the Context API

Unlike **Universal Reactivity** (Module 04), which uses global JavaScript modules to share state across the entire app, Context is hierarchical. Data set in a parent component is available to all its descendants, but *not* to its siblings or parents.

### Key Functions

Svelte provides two primary functions in the `svelte` package:

-   `setContext(key, value)`: Associates a value with a key in the current component's scope.
-   `getContext(key)`: Retrieves the value associated with a key from the nearest parent component.

### Basic Example

**Parent Component:**

```svelte
<script>
	import { setContext } from 'svelte';
	import Child from './Child.svelte';

	// Key can be a string, symbol, or object
	setContext('theme', { color: 'blue' });
</script>

<Child />
```

**Child (or Grandchild) Component:**

```svelte
<script>
	import { getContext } from 'svelte';
	
	const theme = getContext('theme');
</script>

<p style="color: {theme.color}">I am styled by context!</p>
```

---

## 2. Sharing Scoped State with Context

While global modules (singleton state) are great for things like a single current user or application settings, Context is superior when you might have **multiple instances** of a feature.

Imagine a specialized `TodoList` component. If you used a global store, every `TodoList` on the page would share the exact same list of todos. By using Context, each `TodoList` root component can provide its *own* state to its specific items.

### Example: Scoped Counter System

```svelte
<!-- CounterRoot.svelte -->
<script>
	import { setContext } from 'svelte';
	
	let count = $state(0);
	
	// We pass the state object itself or a getter/setter interface
	setContext('counter', {
		get count() { return count },
		increment: () => count++
	});
</script>

<slot />
```

```svelte
<!-- CounterButton.svelte -->
<script>
	import { getContext } from 'svelte';
	const { increment } = getContext('counter');
</script>

<button onclick={increment}>Add +1</button>
```

```svelte
<!-- CounterDisplay.svelte -->
<script>
	import { getContext } from 'svelte';
	const ctx = getContext('counter');
</script>

<p>Current count: {ctx.count}</p>
```

 Now you can have multiple counters that don't interfere with each other:

```svelte
<!-- App.svelte -->
<CounterRoot>
	<CounterDisplay /> <!-- Shows count for Root 1 -->
	<CounterButton />
</CounterRoot>

<CounterRoot>
	<CounterDisplay /> <!-- Shows count for Root 2 -->
	<CounterButton />
</CounterRoot>
```

---

## 3. Handling Components without a Parent Context

If a component calls `getContext('key')` but no parent has called `setContext('key')`, the return value is `undefined`. This can cause errors if your component assumes the context always exists.

### Using Fallbacks

You can't provide a default value directly to `getContext`. Instead, you should check if the result exists.

```svelte
<script>
	import { getContext } from 'svelte';
	
	// distinct from 'undefined' strictly if you typed it potentially
	const context = getContext('theme'); 
	
	const color = context?.color ?? 'red'; // Fallback to red
</script>
```

### Strict Enforcement

Often, a child component *requires* the context to function (e.g., a `<Tab>` inside a `<Tabs>`). In these cases, it's best to throw a helpful error.

```javascript
const ctx = getContext('tabs');
if (!ctx) {
	throw new Error('<Tab> must be used inside a <Tabs> component.');
}
```

---

## 4. Common Pitfalls

Before we look at the best practice, let's identify common mistakes when using potential "shortcuts":

### âŒ Using String Keys
```javascript
setContext('user', ...); // Danger! Any other library could use 'user'
```
**Risk**: Naming collisions. If a third-party component uses `getContext('user')`, it might accidentally grab your context instead of its own, or vice versa.

### âŒ Untyped Returns
```typescript
const context = getContext('user'); // context is 'unknown' or 'any'
```
**Risk**: No autocomplete or type safety. You have to manually cast it (`as UserContext`), which is error-prone.

### âŒ Assuming Context Exists
```typescript
const { count } = getContext('counter'); // Crash if undefined!
```
**Risk**: If the component is used outside its provider, destructuring `undefined` will throw a runtime error.

---

## 5. Encapsulating Context Functions (The Robust Pattern)

To solve these issues, we use the **Typed Context Wrapper** pattern. This involves strict typing, Symbols for keys, and helper functions.

### 1. Define the Context Logic

We create a dedicated file that defines the state shape, key, and accessors. Notice the use of `hasContext` to safely check availability, and a factory function `createCounterState` that now accepts an initial value.

`lib/context/counter-context.svelte.ts`
```typescript
import { getContext, hasContext, setContext } from "svelte";

type CounterContext = {
  value: number;
  increment: () => void;
  reset: () => void;
};

// Unique symbol ensures no collisions
const CONTEXT_KEY = Symbol("counter");

export function setCounterContext(counter: CounterContext) {
  setContext<CounterContext>(CONTEXT_KEY, counter);
}

export function getCounterContext() {
  return getContext<CounterContext>(CONTEXT_KEY);
}

export function hasCounterContext(): boolean {
  return hasContext(CONTEXT_KEY);
}

// Factory function for creating independent state stores with initial value
export function createCounterState(initial: number = 0): CounterContext {
  let count = $state(initial);
  return {
    get value() {
      return count;
    },
    increment: () => {
      count += 1;
    },
    reset: () => {
      count = 0;
    },
  };
}
```

### 2. The Provider Component

The parent component (Provider) uses the factory function to create state and the setter to provide it.

`Counter.svelte`
```svelte
<script lang="ts">
  import { createCounterState, setCounterContext } from "$lib/context/counter-context.svelte";
  import { getAllContexts, type Snippet } from "svelte";

  let {
    children,
    initialCount = 0,
  }: {
    children: Snippet;
    initialCount?: number;
  } = $props();

  // Create fresh state for this instance using the initialCount prop
  setCounterContext(createCounterState(initialCount));

  // Debugging tool to see available contexts
  console.log(getAllContexts());
</script>

{@render children()}
```

### 3. The Consumer Component

The child component (Consumer) can now safely consume the context. It uses a "self-healing" pattern: if context is missing, it falls back to creating its own local state.

`ClickToCount.svelte`
```svelte
<script lang="ts">
  import Button from "./Button.svelte";
  import { createCounterState, getCounterContext, hasCounterContext } from "$lib/context/counter-context.svelte";

  // Robust Pattern: Use context if available, otherwise fallback to local state
  let counter = hasCounterContext() ? getCounterContext() : createCounterState();
</script>

<div class="wrapper">
  <h2>{counter.value}</h2>
  
  <Button onclick={() => counter.increment()}>
    Increment
  </Button>
  
  <Button onclick={() => counter.reset()}>
    Reset
  </Button>
</div>
```

### 4. Usage Example

Now you can use multiple counters with different initial values:

```svelte
<!-- Default initial (0) -->
<ClickToCount />

<!-- Scoped with initial value 10 -->
<Counter initialCount={10}>
  <ClickToCount />
  <ClickToCount />
</Counter>
```

ðŸŽ‰ **Benefits of this approach:**
1.  **Type Safety**: Fully typed without manual casting.
2.  **Encapsulation**: Private `Symbol` key prevents external interference.
3.  **Resilience**: Components work standalone or as part of a system.
4.  **Flexibility**: Supports initial values and scoped state nesting.

