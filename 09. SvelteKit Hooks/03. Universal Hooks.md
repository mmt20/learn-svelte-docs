# 03. Universal Hooks

Universal hooks run on **both** the server and the client. They are defined in `src/hooks.js` or `src/hooks.ts` (note the lack of `.server` or `.client` suffix).

> [!NOTE]
> Universal hooks are about **how URLs map to routes** (`reroute`) and **how data crosses the server/client boundary** (`transport`).

---

## ðŸ”€ The `reroute` Hook

The `reroute` hook allows you to change how URLs are translated into routes **before** the router tries to match them. This is incredibly powerful for:

- Internationalization (i18n) where URL structure differs per language.
- Rewriting legacy URLs.
- Creating "virtual" routes based on data.

Typical use cases:

- ðŸŒ Internationalization (i18n), where URLs differ by language.
- ðŸ§­ Rewriting legacy URLs to new routes without breaking old links.
- ðŸ§± Creating â€œvirtualâ€ routes based on data (slugs, CMS content, etc.).

### Basic Rewriting

```js
/// file: src/hooks.js
const translated = {
    '/en/about': '/en/about',
    '/de/ueber-uns': '/de/about',
    '/fr/a-propos': '/fr/about',
};

/** @type {import('@sveltejs/kit').Reroute} */
export function reroute({ url }) {
    if (url.pathname in translated) {
        return translated[url.pathname];
    }
}
```

In this example:

- Visiting `/de/ueber-uns` renders the route at `/de/about`.
- The browser URL **stays** `/de/ueber-uns` (nice for marketing / SEO).
- The `lang` parameter (if your route is `src/routes/[[lang]]/about`) is derived from the **returned** pathname.

You can think of it as:

> **User URL** â†’ `reroute` â†’ **Internal route ID** â†’ Component renders.

### Asynchronous Rerouting

Since version 2.18, `reroute` can be asynchronous. You can fetch data to decide where to route.

```js
/// file: src/hooks.js
/** @type {import('@sveltejs/kit').Reroute} */
export async function reroute({ url, fetch }) {
    if (url.pathname === '/api/reroute') return;

    // Check a backend API to see if this slug matches a dynamic page
    const api = new URL('/api/check-slug', url);
    api.searchParams.set('slug', url.pathname);

    const result = await fetch(api).then(r => r.json());
    
    // If the API says it's a product page, reroute to the generic product route
    if (result.type === 'product') {
        return `/product/${result.id}`;
    }
}
```

> [!CAUTION]
> `reroute` runs for **every** navigation. Keep it fast! If you do async work, ensure it's performant, otherwise your app will feel sluggish.
>
> When debugging, itâ€™s common to:
> - Temporarily add `console.log(url.pathname)` in `reroute`.
> - Guard against infinite loops by *not* rerouting alreadyâ€‘handled paths.

---

## ðŸ“¦ The `transport` Hook

Typically, when data crosses from the server (handled in `load`) to the client, it must be serializable (JSON). SvelteKit uses `devalue` which supports many types (Date, Map, Set, BigInt, etc.), but not custom classes.

The `transport` hook allows you to register custom encoders and decoders for your own types.

Without `transport`, custom classes are usually turned into **plain objects** on the client. With `transport`, you can send a class instance from the server and get **the same class instance** on the client.

```js
/// file: src/hooks.js
import { Vector } from '$lib/math';

/** @type {import('@sveltejs/kit').Transport} */
export const transport = {
    Vector: {
        // Server: Encode the object into a simple array
        encode: (value) => value instanceof Vector && [value.x, value.y],
        
        // Client: Reconstruct the object from the array
        decode: ([x, y]) => new Vector(x, y)
    }
};
```

Now you can:

- Return a `Vector` from a server `load` function.
- Receive a **real `Vector` instance** in your page component props (with methods, prototypes, etc.).

This keeps your domain logic nicely encapsulated in classes, while still working across the network boundary.

---

## ðŸ”„ Shared Hooks vs Universal Hooks

Both **Shared Hooks** and **Universal Hooks** can run on both client and server, but they serve very different purposes:

| Aspect | Shared Hooks | Universal Hooks |
| :--- | :--- | :--- |
| **File Location** | `src/hooks.server.js` + `src/hooks.client.js` (separate files) | `src/hooks.js` (single file) |
| **Purpose** | Error handling and initialization | URL routing and data serialization |
| **Available Hooks** | `handleError`, `init` | `reroute`, `transport` |
| **When They Run** | On errors (handleError) or app startup (init) | On every navigation (reroute) or data transfer (transport) |
| **Execution Context** | Separate implementations for client/server | Same code runs on both sides |
| **Use Cases** | - Logging errors to Sentry<br>- Database initialization<br>- SDK setup | - i18n URL rewriting<br>- Custom class serialization<br>- Legacy URL mapping |
| **Performance Impact** | Minimal (only on errors/startup) | Can be significant (runs on every route) |
| **Typical Frequency** | Rare (errors) or once (init) | Very frequent (every navigation/data load) |

### When to Use Each

**Use Shared Hooks when:**
- âœ… You need different error handling logic on client vs server
- âœ… You want to initialize services once when the app starts
- âœ… You need to log unexpected errors to monitoring services
- âœ… You want to mask sensitive error details from users

**Use Universal Hooks when:**
- âœ… You need to rewrite URLs for i18n or legacy support
- âœ… You want to send custom class instances across the network
- âœ… The same logic must apply to both client and server navigation
- âœ… You need to map user-facing URLs to internal route structures

> [!TIP]
> **Shared Hooks** are about *handling problems and setup*.  
> **Universal Hooks** are about *transforming URLs and data*.

---

## ðŸ”‘ Key Takeaways

- `reroute` separates the **URL** (what the user sees) from the **Route ID** (what file handles it).
- `reroute` is the only hook that can change *which* page component is rendered for a given URL.
- `transport` lets you use rich domain objects across the network boundary, avoiding manual JSON conversion.
- For many beginner apps, you can **ignore universal hooks at first**; reach for them when you need URL rewriting or custom data transport.
- **Shared Hooks** (`handleError`, `init`) focus on error handling and initialization.
- **Universal Hooks** (`reroute`, `transport`) focus on URL mapping and data serialization.
 