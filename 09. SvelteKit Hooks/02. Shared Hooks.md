# 02. Shared Hooks

Shared hooks can run on **both** the client and the server. They live in:

- `src/hooks.server.js` / `.ts` â€“ for server-side behavior.
- `src/hooks.client.js` / `.ts` â€“ for client-side behavior.

> [!NOTE]
> **Server hooks** (`hooks.server.*`) run only on the server.  
> **Shared hooks** like `handleError` exist in *both* places so you can handle errors consistently on server and client.

---

## âœ… Handling Expected Errors

Before we dive into `handleError`, let's understand how to handle **expected** errors â€” things you know might go wrong, like "user not found" or "invalid input".

### Using `error()` for Expected Errors

SvelteKit provides an `error()` helper for throwing expected HTTP errors. These are **not** caught by `handleError` â€” they go directly to your error pages.

```js
/// file: src/routes/users/[id]/+page.server.js
import { error } from '@sveltejs/kit';

export async function load({ params }) {
    const user = await getUserById(params.id);
    
    if (!user) {
        // Expected error: user doesn't exist
        throw error(404, {
            message: 'User not found',
            code: 'USER_NOT_FOUND'
        });
    }
    
    return { user };
}
```

```js
/// file: src/routes/api/posts/+server.js
import { error, json } from '@sveltejs/kit';

export async function POST({ request }) {
    const data = await request.json();
    
    if (!data.title || !data.content) {
        // Expected error: validation failure
        throw error(400, {
            message: 'Title and content are required',
            errors: {
                title: !data.title ? 'Required' : null,
                content: !data.content ? 'Required' : null
            }
        });
    }
    
    // ... create post
    return json({ success: true });
}
```

### Expected vs Unexpected Errors

| Type | How to Throw | Caught By | Use Case |
| :--- | :--- | :--- | :--- |
| **Expected** | `throw error(status, data)` | Your `+error.svelte` page | 404s, validation failures, permission denied |
| **Unexpected** | `throw new Error(...)` or unhandled exceptions | `handleError` hook | Bugs, API failures, database crashes |

> [!TIP]
> Use `error()` for **business logic failures** (user not found, invalid input, etc.).  
> Let `handleError` catch **programming errors** and unexpected failures.

---

## âš ï¸ The `handleError` Hook

This hook intercepts **unexpected** errors. It allows you to:

1. Log the error (e.g., to Sentry).
2. Return a safe error object to the UI (masking sensitive backend details).

It is **NOT** called for *expected* errors thrown via `error(...)` in your routes â€” those go straight to your error pages as normal HTTP errors.

### Server-Side (`src/hooks.server.js`)

```js
/// file: src/hooks.server.js
/** @type {import('@sveltejs/kit').HandleServerError} */
export async function handleError({ error, event, status, message }) {
    const errorId = crypto.randomUUID();

    console.error(`Error ${errorId}:`, error);

    return {
        message: 'An unexpected error occurred.',
        errorId
    };
}
```

### Client-Side (`src/hooks.client.js`)

```js
/// file: src/hooks.client.js
/** @type {import('@sveltejs/kit').HandleClientError} */
export async function handleError({ error, event, status, message }) {
    const errorId = crypto.randomUUID();

    // Log to external service
    // Sentry.captureException(error, ...);

    return {
        message: 'An unexpected error occurred.',
        errorId
    };
}
```

### Type Safety with `App.Error`

To ensure your returned error object is typed correctly in `$page.error`, update your `app.d.ts`:

```ts
// src/app.d.ts
declare global {
    namespace App {
        interface Error {
            message: string;
            errorId: string;
        }
    }
}
```

Now, anywhere you access `$page.error` (for example in `src/routes/+error.svelte`), TypeScript knows that it has a `message` and `errorId`.

---

## ğŸ” Endâ€‘toâ€‘End Error Flow Example

Here is how an **unexpected** error might flow through your app:

1. A `load` function or action throws an unhandled error.
2. SvelteKit calls `handleError` (server or client, depending where it happened).
3. `handleError` logs the real error and returns a **safe** object.
4. Your error page reads `$page.error` and renders a friendly message.

```js
/// file: src/routes/example/+page.server.js
export async function load() {
    const data = await fetchData();

    if (!data) {
        // Expected: this will NOT trigger handleError
        // throw error(404, 'Not found');
    }

    // Unexpected: maybe a bug or an external API failure
    throw new Error('Something broke unexpectedly');
}
```

The error is then passed to your `handleError` implementation, which returns the object made available as `$page.error` in your error page.

> [!TIP]
> Use `error(status, message)` for **known, expected** failures (like 404).  
> Let `handleError` handle the truly unexpected ones.

---

## ğŸš€ The `init` Hook

The `init` hook runs **once** when the app starts up. It is useful for initializing database connections or other global setup.

> [!NOTE]
> On the client, this runs when the app hydrates. Avoid heavy blocking work here as it will delay interactivity.

```js
/// file: src/hooks.server.js
import * as db from '$lib/server/database';

/** @type {import('@sveltejs/kit').ServerInit} */
export async function init() {
    await db.connect();
    console.log('Database connected!');
}
```

Good use cases for `init`:

- âœ… Setting up **database pools** or connecting to services once per server start.
- âœ… Initializing logging / monitoring SDKs (e.g. Sentry).
- âœ… Warmâ€‘loading configuration or feature flags.

Things to avoid:

- âŒ Heavy blocking work on the **client**, as it delays hydration and interactivity.
- âŒ Longâ€‘running initializations that could be done lazily on first request instead.

---

## ğŸ”‘ Key Takeaways

- Use `handleError` to prevent sensitive error details from leaking to the user.
- `handleError` is for **unexpected** exceptions, not standard 404s or 400s from `error(...)`.
- Keep the **shape** of the returned error small and wellâ€‘typed using `App.Error`.
- `init` is great for one-time setup, but be careful with async blocking on the client.
