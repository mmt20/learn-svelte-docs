# 01. Server Hooks

Server hooks are **app-wide functions that run only on the server**. They live in `src/hooks.server.js` or `src/hooks.server.ts` and let you intercept requests, manage user sessions, tweak responses, and customize validation errors.

> [!IMPORTANT]
> A good mental model: **server hooks are your SvelteKit â€œmiddlewareâ€**. They run for *every* incoming request and can decide what happens next.

---

## ðŸ› ï¸ The `handle` Hook

The `handle` function runs **every time** the SvelteKit server receives a request. It is the most powerful hook and typically your **entry point** for:

- Checking authentication and authorization.
- Adding data to `event.locals` for use in `load` functions and endpoints.
- Tweaking how pages are rendered with `resolve` options.

### Basic Usage

```js
/// file: src/hooks.server.js
/** @type {import('@sveltejs/kit').Handle} */
export async function handle({ event, resolve }) {
    if (event.url.pathname.startsWith('/custom')) {
        return new Response('custom response');
    }

    const response = await resolve(event);
    return response;
}
```

- **`event`**: Represents the request (contains cookies, locals, url, etc.).
- **`resolve`**: A function that renders the route and generates a `Response`.

#### When to use `handle`

Use `handle` when you need logic that:

- ðŸ” **Runs for many or all routes** (e.g. auth, feature flags, maintenance mode).
- ðŸ“¦ **Prepares per-request data** (e.g. current user, locale) and exposes it via `event.locals`.
- ðŸŽ›ï¸ **Modifies the response globally**, such as headers or preloading.

### Managing `locals`

The `event.locals` object is used to pass data between the `handle` hook and your server routes (`+server.*`, `+page.server.*`). This is commonly used for authentication.

**1. Define the type (TypeScript projects):**

```ts
/// file: src/app.d.ts
declare global {
    namespace App {
        interface Locals {
            user: { name: string } | null;
        }
    }
}
export {};
```

**2. Populate in `handle`:**

```js
/// file: src/hooks.server.js
export async function handle({ event, resolve }) {
    // Hypothetical authentication check
    const session = event.cookies.get('session');
    event.locals.user = session ? await getUser(session) : null;

    return resolve(event);
}
```

**3. Use in `load`:**

```js
/// file: src/routes/+page.server.js
export function load({ locals }) {
    return {
        user: locals.user
    };
}
```

> [!NOTE]
> In plain JavaScript projects, you can skip the `app.d.ts` step and still use `event.locals`, you just wonâ€™t get type checking.

---

## ðŸ” Mini Walkthrough: Protecting `/admin`

A classic use of server hooks is protecting admin routes.

```js
/// file: src/hooks.server.js
/** @type {import('@sveltejs/kit').Handle} */
export async function handle({ event, resolve }) {
    const session = event.cookies.get('session');
    event.locals.user = session ? await getUser(session) : null; // 1) Attach user

    const isAdminRoute = event.url.pathname.startsWith('/admin');

    if (isAdminRoute && !event.locals.user?.isAdmin) {
        // 2) Block access if not admin
        return new Response('Forbidden', { status: 403 });
        // or: throw redirect(303, '/login');
    }

    // 3) Let SvelteKit handle the rest
    return resolve(event);
}
```

Now any `+page.server.js` under `/admin` can safely assume that only admins get there.

> [!IMPORTANT]
> **Why protect routes in `handle`, not layout load functions?**
>
> You might be tempted to check auth in a `+layout.server.js` file, but this has problems:
>
> - âŒ **Layout loads run AFTER `handle`** â€” by then, SvelteKit has already started rendering.
> - âŒ **Multiple layouts can conflict** â€” if you have nested layouts, each might check auth differently.
> - âŒ **Harder to debug** â€” auth logic scattered across route files instead of one central place.
>
> âœ… **Do it in `handle`** â€” it runs first, applies globally, and keeps your auth logic in one place. Use `event.locals` to pass the user down to your routes.

---

## âš™ï¸ Advanced `resolve` Options

You can pass options to `resolve` to modify how the page is rendered or which headers are serialized.

```js
const response = await resolve(event, {
    transformPageChunk: ({ html }) => html.replace('old', 'new'),
    filterSerializedResponseHeaders: (name) => name.startsWith('x-'),
    preload: ({ type, path }) => type === 'js' || path.includes('/important/')
});
```

### Understanding `resolve` Options

- **`transformPageChunk`**: Modify HTML chunks before they're sent to the client. Useful for injecting scripts, replacing text, or adding meta tags.
- **`filterSerializedResponseHeaders`**: Control which headers from your `load` functions get sent to the client. By default, SvelteKit only sends headers that start with `x-` or are in a safe list. This function lets you customize that.
  
  ```js
  // Only send custom headers that start with 'x-' to the client
  filterSerializedResponseHeaders: (name) => name.startsWith('x-')
  
  // Or allow specific headers
  filterSerializedResponseHeaders: (name) => 
      name.startsWith('x-') || name === 'content-type'
  ```
  
  > [!TIP]
  > This is important for security â€” you don't want to accidentally leak server-only headers (like `set-cookie` or internal API tokens) to the client.

- **`preload`**: Control which assets get preloaded. Return `true` for assets you want to preload, `false` otherwise. Preloading speeds up navigation but uses bandwidth, so be selective.

---

## ðŸŒ The `handleFetch` Hook

This hook allows you to modify `fetch` requests made inside `load` functions on the server. This is useful for:
- Forwarding cookies to an external API
- Rewriting URLs (e.g., from public API to internal docker container)
- Adding authentication headers automatically

### Basic Usage

```js
/// file: src/hooks.server.js
/** @type {import('@sveltejs/kit').HandleFetch} */
export async function handleFetch({ request, fetch, event }) {
    if (request.url.startsWith('https://api.my-domain.com/')) {
        // Forward cookies to the API sub-domain
        request.headers.set('cookie', event.request.headers.get('cookie'));
    }

    return fetch(request);
}
```

### Common Use Cases

**1. Forwarding cookies to subdomains:**

```js
export async function handleFetch({ request, fetch, event }) {
    // Forward session cookies to your API subdomain
    if (request.url.startsWith('https://api.example.com/')) {
        const cookie = event.request.headers.get('cookie');
        if (cookie) {
            request.headers.set('cookie', cookie);
        }
    }
    return fetch(request);
}
```

**2. Rewriting URLs (internal services):**

```js
export async function handleFetch({ request, fetch, event }) {
    // Rewrite public API URL to internal Docker service
    if (request.url.startsWith('https://api.example.com/')) {
        request = new Request(
            request.url.replace('https://api.example.com', 'http://api-service:3000'),
            request
        );
    }
    return fetch(request);
}
```

**3. Adding authentication headers:**

```js
export async function handleFetch({ request, fetch, event }) {
    // Add API key for internal services
    if (request.url.startsWith('https://internal-api.example.com/')) {
        request.headers.set('x-api-key', process.env.INTERNAL_API_KEY);
    }
    return fetch(request);
}
```

Use `handleFetch` when:

- ðŸ” You need to **forward cookies** or auth headers to an internal API.
- ðŸŒ You want to **rewrite URLs** (e.g. from public hostname to internal service name).
- ðŸ” You need to **add authentication** headers automatically to server-side requests.
- ðŸ§ª You'd like to mock or log certain requests in development.

> [!NOTE]
> `handleFetch` only affects `fetch` calls made in **server-side** `load` functions. Client-side `fetch` calls are not intercepted. This is intentional â€” it keeps your client code simple and secure.

---

## ðŸš« The `handleValidationError` Hook

This hook intercepts Type errors when using standard schema validation (like Valibot or Zod) in server actions or load functions.

```js
/// file: src/hooks.server.js
/** @type {import('@sveltejs/kit').HandleValidationError} */
export function handleValidationError({ issues }) {
    return {
        message: 'Invalid data provided',
        // Be careful not to expose sensitive info
    };
}
```

Typical use cases:

- Showing a **friendly, consistent error message** for invalid form submissions.
- Mapping detailed validation issues into a shape your UI expects.
- Making sure you **never leak raw validation internals** to the browser.

---

## ðŸ”„ Sequence Helper

If you have multiple handle functions (e.g., one for auth, one for logging), you can combine them using `sequence`:

```js
/// file: src/hooks.server.js
import { sequence } from '@sveltejs/kit/hooks';

async function auth({ event, resolve }) { /* ... */ }
async function logging({ event, resolve }) { /* ... */ }

export const handle = sequence(auth, logging);
```

---

## ðŸ”‘ Key Takeaways

- `handle` is your **main entry point** for request interception and global logic.
- Use `event.locals` to pass per-request data (like the current user) to the rest of the app.
- `handleFetch` is essential for server-side API calls that need cookies or header tweaks.
- `handleValidationError` lets you standardize how validation errors surface in the UI.
- Use `sequence` to keep your `handle` logic small and focused instead of one giant function.
