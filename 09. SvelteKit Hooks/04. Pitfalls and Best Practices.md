# 04. Pitfalls and Best Practices

Hooks are powerful, but with great power comes great responsibility. Here are some common pitfalls and how to avoid them, along with a comparison for React developers.

---

## üÜö SvelteKit Hooks vs React Hooks vs Next.js

If you are coming from React or Next.js, the term "Hooks" might be confusing.

| Feature | React "Hooks"<br>(`useState`, `useEffect`) | Next.js Middleware<br>(`middleware.ts`) | SvelteKit "Hooks"<br>(`handle`, `handleError`) |
| :--- | :--- | :--- | :--- |
| **Purpose** | Managing component state and side effects. | Intercepting requests before they reach pages. | Intercepting server requests and app-wide lifecycle events. |
| **Scope** | Local to a Component. | Global to the Application. | Global to the Application. |
| **Execution** | Runs in the browser (client-side). | Runs on the Edge/Server. | Runs on Server (mostly) + Client (some hooks). |
| **File Location** | Inside React components. | `middleware.ts` at project root. | `src/hooks.server.js`, `src/hooks.client.js`, `src/hooks.js` |
| **Use Cases** | - Component state<br>- Side effects<br>- Lifecycle management | - Auth checks<br>- Redirects<br>- Header modification<br>- A/B testing | - Auth + session management<br>- Request/response modification<br>- Error handling<br>- URL rewriting |
| **Svelte Equiv.** | Runes (`$state`, `$effect`) | **This Module!** | **This Module!** |
| **Next.js Equiv.** | **React Hooks** | **Next.js Middleware** | **Next.js Middleware** + API Route Handlers |
| **React Equiv.** | **React Hooks** | Express Middleware | Express Middleware |

> [!IMPORTANT]
> **SvelteKit Hooks are Middleware, not UI Hooks.**
> Think of them as the gatekeepers of your server, similar to Next.js middleware or Express middleware. They are not used for UI logic or interactive state. For that, use [Runes](../01.%20Introduction%20to%20Svelte%20&%20Signal%20Based%20Reactivity/00.%20discover.md).

### Key Differences

**React Hooks vs SvelteKit Hooks:**
- **React hooks** = Component-level state and effects (client-side)
- **SvelteKit hooks** = Application-level middleware (server-side)

**Next.js Middleware vs SvelteKit Hooks:**
- **Next.js middleware** = Single file (`middleware.ts`) for request interception
- **SvelteKit hooks** = Multiple specialized hooks (`handle`, `handleError`, `reroute`, etc.) with more granular control

**Similarities between Next.js and SvelteKit:**
- Both run before pages load
- Both can modify requests/responses
- Both handle authentication and redirects
- Both support edge/server execution

In short:

- Use **React hooks / Svelte runes** for **component state and side effects**.
- Use **Next.js middleware / SvelteKit hooks** for **app‚Äëwide request handling and middleware‚Äëstyle logic**.

---

## ‚úÖ Checklist Before Adding a Hook

Before you add new logic to a hook, ask yourself:

- Does this really need to run for **many or all routes**, or could it live in a single `load` / endpoint?
- Is this specific to **one page**? If yes, it probably belongs in that page‚Äôs route instead.
- Will this logic make every request **significantly slower** if it runs globally?
- Am I touching **authentication, security, or sensitive data**? If yes, hooks are often the right place.

If most of the answers lean ‚Äúglobal‚Äù or ‚Äúcross‚Äëcutting concern‚Äù, a hook is a good fit.

---

## ‚ö†Ô∏è Common Pitfalls

### 1. Modifying Immutable Headers

Some response headers are immutable (e.g., when you use `Response.redirect`). Attempting to `set` headers on these responses will throw a TypeError.

**Bad:**
```js
const response = await resolve(event);
// ‚ùå CRASHES if response is a redirect
response.headers.set('x-custom', 'value');
return response;
```

**Good:**
```js
const response = await resolve(event);
try {
    response.headers.set('x-custom', 'value');
} catch {
    // Determine if you need to clone() or just ignore
    const newResponse = new Response(response.body, response);
    newResponse.headers.set('x-custom', 'value');
    return newResponse;
}
```
*Or better yet, set known headers before resolving if possible, or only on successful responses.*

### 2. Heavy Blocking in `handle`

The `handle` hook runs for **every request**.
- Database calls are fine.
- Long-running crypto operations or external API calls with 10s timeouts will kill your server's throughput.

### 3. Leaking Data in `handleValidationError` or `handleError`

When returning error objects, **never** simply return the raw error.

**Bad:**
```js
return { message: error.message, stack: error.stack }; // ‚ùå Exposes database queries/paths
```

**Good:**
```js
console.error(error); // Log the real error on the server
return { message: 'Something went wrong.' }; // ‚úÖ Safe for user
```

> [!WARNING]
> Be extra careful not to include:
> - Raw database error messages or SQL.
> - File paths, environment variable values, or stack traces.
> - Any secrets or tokens.  
> Keep what you return to the browser **small and generic**.

### 4. Overusing `preload`

In `handle`, you can configure preloading.
```js
preload: ({ type, path }) => type === 'js' || path.includes('/important/')
```
While preloading assets helps performance, preloading *everything* hurts it. The browser has limited bandwidth. Only preload critical assets (fonts, hero images, main layout CSS/JS).

---

## üèÜ Best Practices

1. **Use `sequence` for Organization**: Don't write a 500-line `handle` function. Split auth, logging, and headers into separate functions and compose them.
2. **Type Everything**: Use JSDoc types (`/** @type {import('@sveltejs/kit').Handle} */`) to get autocomplete for `event` properties.
3. **Use `locals` for Auth**: It is the standard, secure way to pass user identity from the hook to your pages. Do not try to re-parse cookies in every `+page.server.js`.
4. **Keep `reroute` Fast**: Since it blocks navigation, avoid complex logic or slow fetches in this hook.
5. **Centralize Error Handling**: Use `handleError` / `handleValidationError` to sanitize errors in one place.
6. **Prefer Simple Data Shapes**: When in doubt, serialize plain objects; use `transport` only when you really need rich classes.

---

**You've mastered Hooks! üéâ**  
You now have the tools to build secure, robust, and well‚Äëarchitected SvelteKit applications.
