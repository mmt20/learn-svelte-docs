# Advanced Universal Reactivity Patterns

In this final section, we'll explore advanced features that make Svelte 5's universal reactivity even more powerful: `$effect.tracking()`, `createSubscriber`, and reactive window properties.

---

## üéØ Checking for Reactivity with `$effect.tracking()`

`$effect.tracking()` is an advanced utility that tells you **if the current code is running inside a tracking context** (like an effect or a derived calculation).

This is primarily useful for:
- **Library Authors**: To ensure their reactive functions are being used correctly.
- **Debugging**: To understand why something isn't updating.
- **Optimization**: To skip expensive work if nobody is listening.

### How it Works

It returns a boolean:
- **`true`**: Dependencies accessed now **WILL** be tracked (e.g., inside `$effect`, `$derived`, or the template).
- **`false`**: Dependencies accessed now **WILL NOT** be tracked (e.g., inside `setTimeout`, event handlers, or raw JS functions).

### Example: Optimizing Subscriptions

```svelte
<script>
function createLazyValue() {
  let value = $state(0);

  return {
    get value() {
      if ($effect.tracking()) {
        console.log('Reactive consumer detected.');
      } else {
        console.log('Non-reactive read.');
      }
      return value;
    }
  };
}

// Usage
const lazy = createLazyValue();

$effect(() => {
  console.log(lazy.value); // üëÄ Logs "Reactive consumer detected."
});

console.log(lazy.value);   // üôà Logs "Non-reactive read."
</script>
```

### Correct Pattern for Non-Tracking Reads

If you need to read a signal without tracking it (e.g., inside an effect but you don't want it to re-run when that signal changes), use `untrack`:

```typescript
import { untrack } from 'svelte';

$effect(() => {
    console.log('Use name:', user.name); // Tracked
    
    // Read without subscribing
    const email = untrack(() => user.email); 
    console.log('User email (untracked):', email);
});
```

> [!NOTE]
> `untrack` **guarantees** no dependency registration, unlike `$effect.tracking()` which only **observes** the context. Use `$effect.tracking()` to *check* if you are being tracked, and `untrack` to *control* tracking.





---

## üîå Using `createSubscriber` to Track External Values

`createSubscriber` is a powerful utility from `svelte/reactivity` that lets you make **external values** reactive. It's perfect for browser APIs like scroll position, mouse position, or window size.

### The Problem: Browser APIs Aren't Reactive

You *could* manually try to sync state using an effect inside a component:

```svelte
<script>
    let scrollY = $state(0);

    $effect(() => {
        const handleScroll = () => {
            scrollY = window.scrollY;
        };

        window.addEventListener('scroll', handleScroll);
        
        return () => {
            window.removeEventListener('scroll', handleScroll);
        };
    });
</script>

<p>Scroll position: {scrollY}</p>
```

**Why is this suboptimal?**
1.  **Not Reusable**: You have to copy-paste this logic into every component that needs scroll position.
2.  **Boilerplate**: It's verbose to write the setup and teardown every time.
3.  **Component-Bound**: You can't use this reactive value in a plain `.svelte.ts` module or a utility function easily.

We want a **portable**, **universal** way to make `window.scrollY` reactive so we can import it anywhere.

### Solution: `createSubscriber`

```typescript
// lib/utils/scroll.svelte.ts
import { createSubscriber } from 'svelte/reactivity';

export const scrollY = createSubscriber(0, (update) => {
    const handleScroll = () => {
        update(window.scrollY);
    };
    
    window.addEventListener('scroll', handleScroll);
    
    // Return cleanup function
    return () => {
        window.removeEventListener('scroll', handleScroll);
    };
});
```

### Using the Reactive Scroll Position

```svelte
<script>
    import { scrollY } from '$lib/utils/scroll.svelte';
</script>

<div class="scroll-indicator">
    <p>Scroll position: {scrollY}px</p>
    
    {#if scrollY > 100}
        <button class="back-to-top">‚Üë Back to Top</button>
    {/if}
</div>
```

**Key Point**: `scrollY` is now fully reactive! It updates automatically as you scroll.

---

## üîç How does `createSubscriber` Work?

Let's understand the anatomy of `createSubscriber`:

```typescript
createSubscriber(initialValue, (update) => {
    // Setup code: add event listeners, start timers, etc.
    
    // Call update() whenever the value changes
    update(newValue);
    
    // Return cleanup function
    return () => {
        // Cleanup: remove listeners, clear timers, etc.
    };
});
```

### Parameters

1. **`initialValue`**: The starting value
2. **`setup function`**: Receives an `update` callback
   - Call `update(newValue)` to trigger reactivity
   - Return a cleanup function

### Example: Mouse Position Tracker

```typescript
// lib/utils/mouse.svelte.ts
import { createSubscriber } from 'svelte/reactivity';

export const mousePosition = createSubscriber(
    { x: 0, y: 0 },
    (update) => {
        const handleMouseMove = (e: MouseEvent) => {
            update({ x: e.clientX, y: e.clientY });
        };
        
        window.addEventListener('mousemove', handleMouseMove);
        
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
        };
    }
);
```

```svelte
<script>
    import { mousePosition } from '$lib/utils/mouse.svelte';
</script>

<p>Mouse: ({mousePosition.x}, {mousePosition.y})</p>
```

### Example: Window Size Tracker

```typescript
// lib/utils/window.svelte.ts
import { createSubscriber } from 'svelte/reactivity';

export const windowSize = createSubscriber(
    { width: 0, height: 0 },
    (update) => {
        const updateSize = () => {
            update({
                width: window.innerWidth,
                height: window.innerHeight
            });
        };
        
        // Set initial value
        updateSize();
        
        window.addEventListener('resize', updateSize);
        
        return () => {
            window.removeEventListener('resize', updateSize);
        };
    }
);
```

---

## üèóÔ∏è Using `createSubscriber` in a Reusable Class

You can encapsulate `createSubscriber` in a class for better organization. Here is a robust implementation using `svelte/events`:

```typescript
// lib/utils/scrollY.svelte.ts
import { browser } from "$app/environment";
import { on } from "svelte/events";
import { createSubscriber } from "svelte/reactivity";

class ScrollY {
  #subscribers;
  
  constructor() {
    this.#subscribers = createSubscriber((update) => {
      console.log("subscribed");

      // 'on' handles adding and removing the listener automatically if used in an effect, 
      // but here we use it to explicitly return the cleanup function.
      const off = on(window, "scroll", update);

      return () => {
        console.log("unsubscribed");
        off();
      };
    });
  }

  get current() {
    // Register dependency
    this.#subscribers();
    return browser ? Math.floor(window.scrollY) : 0;
  }
}

export default new ScrollY();
```

### Using the Reactive Class

```svelte
<script>
    import scrollY from '$lib/utils/scrollY.svelte';
</script>

<div class="scroll-info">
    <p>Vertical Scroll: {scrollY.current}px</p>
    
    {#if scrollY.current > 100}
        <div class="scroll-indicator">Scrolled past 100px!</div>
    {/if}
</div>
```

---

## ü™ü Reactive Window Properties

Svelte provides built-in reactive window properties in the `svelte/reactivity/window` module:

```typescript
import { 
    scrollX, 
    scrollY, 
    innerWidth, 
    innerHeight,
    online 
} from 'svelte/reactivity/window';
```

### Available Properties

| Property | Description |
| :--- | :--- |
| `scrollX` | Horizontal scroll position |
| `scrollY` | Vertical scroll position |
| `innerWidth` | Window width |
| `innerHeight` | Window height |
| `outerWidth` | Browser window width |
| `outerHeight` | Browser window height |
| `online` | Network connection status |

### Example: Responsive Layout

```svelte
<script>
    import { innerWidth, innerHeight } from 'svelte/reactivity/window';
    
    $derived isMobile = innerWidth < 768;
    $derived isTablet = innerWidth >= 768 && innerWidth < 1024;
    $derived isDesktop = innerWidth >= 1024;
</script>

<div class="layout">
    <p>Window size: {innerWidth} x {innerHeight}</p>
    
    {#if isMobile}
        <MobileLayout />
    {:else if isTablet}
        <TabletLayout />
    {:else}
        <DesktopLayout />
    {/if}
</div>
```

### Example: Scroll Progress Bar

```svelte
<script>
    import { scrollY, innerHeight } from 'svelte/reactivity/window';
    
    $derived maxScroll = document.documentElement.scrollHeight - innerHeight;
    $derived scrollProgress = maxScroll > 0 ? (scrollY / maxScroll) * 100 : 0;
</script>

<div class="progress-bar" style="width: {scrollProgress}%"></div>

<style>
    .progress-bar {
        position: fixed;
        top: 0;
        left: 0;
        height: 4px;
        background: linear-gradient(to right, #3b82f6, #8b5cf6);
        transition: width 0.1s ease;
        z-index: 1000;
    }
</style>
```

### Example: Online/Offline Indicator

```svelte
<script>
    import { online } from 'svelte/reactivity/window';
</script>

<div class="status" class:offline={!online}>
    {online ? 'üü¢ Online' : 'üî¥ Offline'}
</div>

<style>
    .status {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 10px 20px;
        border-radius: 20px;
        background: #10b981;
        color: white;
        transition: background 0.3s;
    }
    
    .status.offline {
        background: #ef4444;
    }
</style>
```

---

## ‚ö†Ô∏è Pitfalls and Best Practices

### 1. **Memory Leaks with `createSubscriber`**

Always return a cleanup function:

```typescript
// ‚ùå Memory leak - listener never removed
export const scroll = createSubscriber(0, (update) => {
    window.addEventListener('scroll', () => update(window.scrollY));
    // Missing cleanup!
});

// ‚úÖ Proper cleanup
export const scroll = createSubscriber(0, (update) => {
    const handler = () => update(window.scrollY);
    window.addEventListener('scroll', handler);
    return () => window.removeEventListener('scroll', handler);
});
```

### 2. **Performance with High-Frequency Events**

Use throttling or debouncing for events like scroll or mousemove:

```typescript
function throttle(fn: Function, delay: number) {
    let lastCall = 0;
    return (...args: any[]) => {
        const now = Date.now();
        if (now - lastCall >= delay) {
            lastCall = now;
            fn(...args);
        }
    };
}

export const scrollY = createSubscriber(0, (update) => {
    const handler = throttle(() => update(window.scrollY), 100);
    window.addEventListener('scroll', handler, { passive: true });
    return () => window.removeEventListener('scroll', handler);
});
```

### 3. **SSR Compatibility**

Check for `window` before creating subscribers:

```typescript
export const scrollY = typeof window !== 'undefined'
    ? createSubscriber(0, (update) => {
        const handler = () => update(window.scrollY);
        window.addEventListener('scroll', handler);
        return () => window.removeEventListener('scroll', handler);
    })
    : { valueOf: () => 0 }; // Fallback for SSR
```

---

## üéì Key Takeaways

- ‚úÖ `$effect.tracking()` allows conditional dependency tracking
- ‚úÖ `createSubscriber` makes external values reactive
- ‚úÖ Always return cleanup functions from subscribers
- ‚úÖ Use `svelte/reactivity/window` for built-in reactive window properties
- ‚úÖ Combine these features for powerful reactive patterns
- ‚úÖ Be mindful of performance and memory leaks

---

## üìù Module Summary

In this module, you've learned:

1. **Sharing Logic vs Sharing State**
   - Factory functions and classes for isolated state
   - Objects, class instances, and proxies for shared state

2. **Global Effects**
   - Using `$effect.root()` for component-independent effects
   - Persisting state to localStorage automatically

3. **Advanced Features**
   - `$effect.tracking()` for fine-grained control
   - `createSubscriber` for external reactivity
   - Reactive window properties from `svelte/reactivity/window`

---

## üöÄ What's Next?

You've mastered universal reactivity in Svelte 5! You can now:

- Create reactive state anywhere in your application
- Share logic and state between components
- Build complex reactive patterns with global effects
- Integrate external systems reactively

**Continue your Svelte 5 journey by exploring other modules! üéâ**
