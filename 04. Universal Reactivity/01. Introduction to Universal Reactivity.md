# Introduction to Universal Reactivity

Universal reactivity is one of Svelte 5's most revolutionary features. Unlike traditional frameworks where reactivity is tied to components, Svelte 5 allows you to create reactive state **anywhere**‚Äîin regular JavaScript modules, utility functions, or shared services.

In this section, we'll explore how to extract logic containing state and effects that can be reused in multiple components, and how to share state between multiple components.

---

## ü§î What is Universal Reactivity?

**Universal reactivity** means that Svelte's reactivity system works everywhere in your codebase, not just inside `.svelte` components.

### Traditional Component-Scoped Reactivity

In most frameworks (including Svelte 4), reactive state is component-scoped:

```svelte
<!-- Svelte 4 - Reactivity only works inside components -->
<script>
  let count = 0; // Reactive only in this component
  
  function increment() {
    count++;
  }
</script>

<button on:click={increment}>{count}</button>
```

### Universal Reactivity in Svelte 5

With Svelte 5, you can create reactive state in **any JavaScript file**:

```javascript
// counter.svelte.js - A regular JavaScript module!
export const counter = $state({ count: 0 });

export function increment() {
  counter.count++;
}
```

```svelte
<!-- App.svelte -->
<script>
  import { counter, increment } from './counter.svelte.js';
</script>

<button onclick={increment}>{counter.count}</button>
```

The state updates automatically, even though it's defined outside the component! üéâ

> [!TIP]
> Use the `.svelte.js` or `.svelte.ts` extension to get proper syntax highlighting and IDE support for runes in JavaScript/TypeScript files!

---

## üîÑ Sharing Logic vs Sharing State

Before we dive into the patterns, it's crucial to understand the difference:

### Sharing Logic
Each component instance gets **its own state**. We're only sharing the logic/behavior.

### Sharing State
All components reference **the same state**. Changes in one component affect all others.

---

## üì¶ Extracting Logic in a Function

When you want to share logic but keep state isolated per component, use a factory function:

```typescript
// lib/utils/counter.svelte.ts
function createCounter() {
    let count = $state(0);
    
    $effect(() => {
        console.log('Count changed:', count);
    });
    
    return {
        get value() {
            return count;
        },
        increment: () => {
            count += 1;
        },
        reset: () => {
            count = 0;
        }
    };
}

export default createCounter;
```

### Using the Function

```svelte
<script lang="ts">
    import createCounter from '$lib/utils/counter.svelte';

    const counter = createCounter();
</script>

<div class="wrapper">
    <h2>{counter.value}</h2>
    <button onclick={counter.increment}>Increment</button>
    <button onclick={counter.reset}>Reset</button>
</div>
```

**Key Point**: Each component that calls `createCounter()` gets its own independent state and effect.

### Why Use a Getter?

```javascript
// ‚ùå This won't work - exports the value, not the reactive binding
export function createCounter() {
    let count = $state(0);
    return {
        value: count, // This exports the current value (0), not the reactive state
        increment: () => count++
    };
}

// ‚úÖ This works - getter maintains reactivity
export function createCounter() {
    let count = $state(0);
    return {
        get value() {
            return count; // This maintains the reactive connection
        },
        increment: () => count++
    };
}
```

---

## üèóÔ∏è Extracting Logic with Classes

Classes provide a cleaner syntax for the same pattern:

```typescript
// lib/utils/counter.svelte.ts
class Counter {
    value = $state(0);

    constructor() {
        $effect(() => {
            console.log('Count changed:', this.value);
        });
    }
    
    increment = () => {
        this.value += 1;
    };
    
    reset = () => {
        this.value = 0;
    };
}

export default Counter;
```

### Using the Class

```svelte
<script lang="ts">
    import Counter from '$lib/utils/counter.svelte';

    const counter = new Counter();
</script>

<div class="wrapper">
    <h2>{counter.value}</h2>
    <button onclick={counter.increment}>Increment</button>
    <button onclick={counter.reset}>Reset</button>
</div>
```

**Key Point**: Each component that creates a `new Counter()` gets its own independent instance with its own state.

### Class vs Function Approach

| Aspect | Function | Class |
| :--- | :--- | :--- |
| **Syntax** | Requires getters for primitives | Automatic getters/setters |
| **Readability** | More explicit | Cleaner, more OOP |
| **TypeScript** | Good support | Excellent support |
| **Use Case** | Simple utilities | Complex state logic |

---

## üåê Sharing State Using Object Setters and Getters

When you define state **outside** a function or class, you can share it across all components:

```typescript
// lib/utils/counter.svelte.ts
let count = $state(0);

export default {
    get value() {
        return count;
    },
    set value(v) {
        count = v;
    },
    increment() {
        count += 1;
    },
    reset() {
        count = 0;
    }
};
```

> [!WARNING]
> If your state is a primitive (number, string, boolean), you **cannot export it directly**. You must use getters/setters to maintain reactivity. Otherwise, you'll export the value at creation time, losing reactivity.

### Using Shared State

```svelte
<!-- ComponentA.svelte -->
<script lang="ts">
    import counter from '$lib/utils/counter.svelte';
    const { increment, reset } = counter;
</script>

<div class="wrapper">
    <h2>{counter.value}</h2>
    <button onclick={increment}>Increment</button>
    <button onclick={reset}>Reset</button>
</div>
```

```svelte
<!-- ComponentB.svelte -->
<script lang="ts">
    import counter from '$lib/utils/counter.svelte';
</script>

<div class="wrapper">
    <p>Current count: {counter.value}</p>
</div>
```

**Key Point**: Both components reference the **same state**. When ComponentA increments, ComponentB sees the change immediately!

---

## üé® Sharing State Using Classes

Instead of objects with getters/setters, export a class **instance**:

```typescript
// lib/utils/counter.svelte.ts
class Counter {
    value = $state(0);

    increment = () => {
        this.value += 1;
    };
    
    reset = () => {
        this.value = 0;
    };
}

// Export an instance, not the class
const counter = new Counter();
export default counter;
```

### Using the Shared Instance

```svelte
<script lang="ts">
    import counter from '$lib/utils/counter.svelte';
</script>

<div class="wrapper">
    <h2>{counter.value}</h2>
    <button onclick={counter.increment}>Increment</button>
    <button onclick={counter.reset}>Reset</button>
</div>
```

**Advantage**: Svelte automatically creates getters/setters for class properties, so you don't need to define them manually!

---

## üîÆ Sharing State with Proxy

The easiest approach: use an **object** instead of primitives. Svelte proxifies the object automatically:

```typescript
// lib/utils/counter.svelte.ts
const count = $state({ value: 0 });

export default count;

export function increment() {
    count.value += 1;
}

export function reset() {
    count.value = 0;
}
```

### Using Proxy-Based State

```svelte
<script lang="ts">
    import counter, { increment, reset } from '$lib/utils/counter.svelte';
</script>

<div class="wrapper">
    <h2>{counter.value}</h2>
    <button onclick={increment}>Increment</button>
    <button onclick={reset}>Reset</button>
</div>
```

**Why This Works**: As we explained in **[Module 03: Javascript Proxies and Object Setters & Getters](../03.%20Deep%20State%20Reactivity/01.%20Javascript%20Proxies%20and%20Object%20Setters%20&%20Getters.md)**, when you use `$state({})` with an object, Svelte wraps that object in a **JavaScript Proxy**.

This Proxy intercepts all operations (like setting or getting properties). So when you export this proxified object and import it in another file:
1. You are importing the **Proxy**, not the original object.
2. Any modification to its properties (`count.value = 5`) is intercepted by the Proxy.
3. The Proxy notifies Svelte's reactivity system to update any component causing the side effect.
4. Because it's the *same* Proxy instance being shared, all components stay in sync!

---

## üìä Comparison: Three Approaches to Sharing State

| Approach | Pros | Cons | Best For |
| :--- | :--- | :--- | :--- |
| **Object with Getters/Setters** | Works with primitives | Verbose, manual getters | Simple state |
| **Class Instance** | Clean syntax, auto getters | Slightly more boilerplate | Complex logic |
| **Proxy Object** | Simplest, least code | Must use objects | Most use cases |

---

## üéØ Real-World Example: Theme Manager

Let's build a practical example using the proxy approach:

```typescript
// lib/stores/theme.svelte.ts
const theme = $state({
    mode: 'light' as 'light' | 'dark',
    primaryColor: '#3b82f6',
    fontSize: 16
});

export default theme;

export function toggleTheme() {
    theme.mode = theme.mode === 'light' ? 'dark' : 'light';
}

export function setPrimaryColor(color: string) {
    theme.primaryColor = color;
}

export function increaseFontSize() {
    theme.fontSize = Math.min(theme.fontSize + 2, 24);
}

export function decreaseFontSize() {
    theme.fontSize = Math.max(theme.fontSize - 2, 12);
}
```

### Using the Theme Manager

```svelte
<!-- Header.svelte -->
<script lang="ts">
    import theme, { toggleTheme } from '$lib/stores/theme.svelte';
</script>

<header class:dark={theme.mode === 'dark'}>
    <h1 style="color: {theme.primaryColor}">My App</h1>
    <button onclick={toggleTheme}>
        {theme.mode === 'light' ? 'üåô' : '‚òÄÔ∏è'}
    </button>
</header>
```

```svelte
<!-- Settings.svelte -->
<script lang="ts">
    import theme, { increaseFontSize, decreaseFontSize } from '$lib/stores/theme.svelte';
</script>

<div class="settings">
    <h2>Settings</h2>
    <p>Current theme: {theme.mode}</p>
    <p>Font size: {theme.fontSize}px</p>
    
    <button onclick={increaseFontSize}>A+</button>
    <button onclick={decreaseFontSize}>A-</button>
</div>
```

---

## ‚ö†Ô∏è Important: Server-Side Safety & State Scoping

While exporting shared state is powerful, it comes with important caveats, especially for Server-Side Rendering (SSR).

### üö® Server-Side Data Leaks

On the client (browser), exporting a shared state object works fine because each user has their own browser instance.

**However, on the server:**
- Node.js/Bun servers are long-lived processes.
- Modules are evaluated **once** and shared across all requests.
- If you export a mutable state object (like `export const store = $state({...})`), **ALL users will share that same object**.

> [!CAUTION]
> **Never** use global shared state for user-specific data on the server. If User A logs in and sets their name, User B might see User A's name because they are accessing the exact same variable in memory!

### üîí Scoping State

Sometimes you don't want state to be truly "global" (available everywhere). You might want to:
- Scope state to a specific part of your app (e.g., a multi-step form).
- Create a fresh instance of state for each request (to avoid server leaks).

### The Solution: Context

To solve both server-side leaks and scoping issues, Svelte provides **Context**. Context allows you to associate state with a specific component tree rather than a global module.

We will discuss **Context** in detail in a future module suitable for these scenarios!

---

## ‚ö†Ô∏è Pitfalls to Avoid

### 1. **Exporting Primitives Directly**

```typescript
// ‚ùå DON'T DO THIS - Loses reactivity!
export let count = $state(0);

// When you import this, you get the value 0, not the reactive state
```

```typescript
// ‚úÖ DO THIS - Maintains reactivity
const state = $state({ count: 0 });
export default state;

// OR use getters
let count = $state(0);
export default {
    get value() { return count; },
    set value(v) { count = v; }
};
```

### 2. **Forgetting `.svelte.js` Extension**

```typescript
// ‚ùå counter.js - Runes won't work!
export const count = $state(0); // Error: $state is not defined

// ‚úÖ counter.svelte.js - Runes work!
export const count = $state({ value: 0 }); // Works!
```

### 3. **Mixing Sharing Logic and Sharing State**

```typescript
// ‚ùå Confusing - Is this shared or per-component?
export class Counter {
    value = $state(0);
}
// If you export the class, each component gets its own state
// If you export an instance, all components share state

// ‚úÖ Be explicit
// For sharing logic:
export class Counter { /* ... */ }

// For sharing state:
const counter = new Counter();
export default counter;
```

---

## üéì Key Takeaways

- ‚úÖ **Sharing Logic**: Use factory functions or classes (export the class itself)
- ‚úÖ **Sharing State**: Define state outside functions/classes and export it
- ‚úÖ **Primitives**: Use getters/setters or wrap in objects to maintain reactivity
- ‚úÖ **Proxy Objects**: The easiest approach for most use cases
- ‚úÖ **File Extension**: Use `.svelte.js` or `.svelte.ts` for rune support

---

## üöÄ Next Steps

Now that you understand the fundamentals, let's explore:

- **[Reactive Modules and Shared State](./02.%20Reactive%20Modules%20and%20Shared%20State.md)**: Global effects and localStorage persistence
- **[Advanced Universal Reactivity Patterns](./03.%20Advanced%20Universal%20Reactivity%20Patterns.md)**: Advanced features like `$effect.tracking()` and `createSubscriber`

---

**You now understand the core concepts of universal reactivity! Let's dive deeper! üéØ**
