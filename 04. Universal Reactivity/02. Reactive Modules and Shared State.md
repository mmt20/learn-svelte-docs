# Reactive Modules and Shared State

Now that you understand how to share logic and state between components, let's explore how to create global effects for shared state and persist that state to localStorage.

---

## ğŸŒ Defining Effects Globally for Shared State

When you have shared state, you can also create effects that depend on that state **globally**, not inside any component. This is useful for:

- Logging state changes
- Syncing with external systems
- Side effects that should run regardless of which component triggered the change

### The Problem with Component-Level Effects

```svelte
<!-- ComponentA.svelte -->
<script>
    import counter from '$lib/stores/counter.svelte';
    
    // This effect only runs when ComponentA is mounted
    $effect(() => {
        console.log('Count changed:', counter.value);
    });
</script>
```

If ComponentA is unmounted, the effect stops running, even though the state still exists!

### Solution: Global Effects with `$effect.root()`

```typescript
// lib/stores/counter.svelte.ts
const count = $state({ value: 0 });

// Global effect - runs regardless of component lifecycle
$effect.root(() => {
    $effect(() => {
        console.log('Count changed:', count.value);
    });
});

export default count;

export function increment() {
    count.value += 1;
}

export function reset() {
    count.value = 0;
}
```

> [!IMPORTANT]
> You **must** wrap global effects in `$effect.root()`. This tells Svelte that the effect is not tied to any component's lifecycle.

### How `$effect.root()` Works

```typescript
// Without $effect.root() - ERROR!
const state = $state({ value: 0 });

$effect(() => {
    console.log(state.value); // Error: effect must be called within component
});

// With $effect.root() - Works!
const state = $state({ value: 0 });

$effect.root(() => {
    $effect(() => {
        console.log(state.value); // âœ… Works globally
    });
});
```

### Cleanup with `$effect.root()`

`$effect.root()` returns a cleanup function:

```typescript
const state = $state({ value: 0 });

const cleanup = $effect.root(() => {
    $effect(() => {
        console.log('State changed:', state.value);
    });
    
    // Return cleanup logic
    return () => {
        console.log('Cleaning up global effect');
    };
});

// Later, if you need to stop the effect:
cleanup();
```

---

## ğŸ’¾ Persisting Shared State to LocalStorage with Effects

A common use case for global effects is persisting state to localStorage.

### Basic localStorage Persistence

```typescript
// lib/stores/counter.svelte.ts
import { browser } from "$app/environment";

const storedCount = browser && localStorage.getItem("count") && JSON.parse(localStorage.getItem("count")!);

const count = $state({ value: storedCount ? storedCount : 0 });
export default count;

export function increment() {
  count.value += 1;
}

$effect.root(() => {
  $effect(() => {
    if (browser) {
        localStorage.setItem("count", JSON.stringify(count.value));
    }
  });
});

export function reset() {
  count.value = 0;
}
```

### ğŸ§ Understanding the Pattern

1. **Safety First with `browser` check**: 
   We import `browser` from `$app/environment`. This is critical because this file might be imported on the server (during SSR), where `localStorage` doesn't exist. The `browser && ...` check ensures we only try to access `localStorage` on the client.


2. **Global Tracking with `$effect.root`**:
   We wrap our effect in `$effect.root` so it runs globally, independent of any component's lifecycle. It starts running as soon as this module is imported.

3. **Automatic Persistence**:
   Inside `$effect`, we use `JSON.stringify(count.value)`. Crucially, accessing `count.value` registers it as a dependency. Svelte's reactivity system now "watches" `count.value`. Whenever it changes, this effect re-runs and updates `localStorage`.



### Using Persisted State

```svelte
<script lang="ts">
    import count, { increment, reset } from '$lib/stores/counter.svelte';
</script>

<div class="counter-app">
    <h1>Persistent Counter</h1>
    <p>Current count: {count.value}</p>
    
    <button onclick={increment}>Increment</button>
    <button onclick={reset}>Reset</button>

    <p><em>Refresh the page - the count remains!</em></p>
</div>
```

**Key Point**: Every change to `count` automatically saves to localStorage because the effect tracks `count.value`!

Revisiting what we learned in **[Module 03: Deep State Reactivity](../03.%20Deep%20State%20Reactivity/02.%20Deep%20State%20Reactivity%20in%20Svelte.md)**:

1.  **Proxies at Work**: `count` is a reactive object (a Proxy).
2.  **Fine-Grained Tracking**: When our effect runs `JSON.stringify(count.value)`, it reads the `value` property.
3.  **Automatic Dependency**: Svelte's reactivity system notices this read operation and registers `count.value` as a dependency for this effect.
4.  **Surgical Updates**: Just like in our deep state examples, Svelte knows *exactly* that this specific effect depends on `count.value`. When you mutate it (`count.value += 1`), Svelte re-runs precisely this effect.

This explains why we don't need manual subscriptions or `set` callsâ€”the act of *reading* the value inside the effect creates the bond!

---

## âš ï¸ Pitfalls and Best Practices

### 1. **SSR Considerations**

Always check for `window` before accessing localStorage:

```typescript
// âŒ Will crash on server
const stored = localStorage.getItem('key');

// âœ… Safe for SSR
const stored = typeof window !== 'undefined' 
    ? localStorage.getItem('key') 
    : null;
```

### 2. **Initial Effect Run**

Global effects run immediately, including on initialization:

```typescript
const count = $state({ value: 0 });

$effect.root(() => {
    $effect(() => {
        // This runs immediately with value 0, then on every change
        console.log('Count:', count.value);
        localStorage.setItem('count', JSON.stringify(count.value));
    });
});
```

To skip the initial run:

```typescript
const count = $state({ value: 0 });
let isFirst = true;

$effect.root(() => {
    $effect(() => {
        if (isFirst) {
            isFirst = false;
            return;
        }
        localStorage.setItem('count', JSON.stringify(count.value));
    });
});
```

### 3. **Memory Leaks**

Global effects persist for the lifetime of your app. Clean up when needed:

```typescript
// Create cleanup function
const cleanup = $effect.root(() => {
    $effect(() => {
        console.log('State changed');
    });
});

// Clean up when no longer needed
cleanup();
```

### 4. **Circular Dependencies**

Be careful not to create infinite loops:

```typescript
// âŒ Infinite loop!
const state = $state({ value: 0 });

$effect.root(() => {
    $effect(() => {
        state.value = state.value + 1; // This triggers the effect again!
    });
});

// âœ… Only react, don't modify
$effect.root(() => {
    $effect(() => {
        console.log('Value is:', state.value); // Safe
    });
});
```

---

## ğŸ¯ Best Practices

### 1. **Organize by Feature**

```
src/
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ stores/
â”‚       â”œâ”€â”€ auth.svelte.ts       # Authentication state
â”‚       â”œâ”€â”€ cart.svelte.ts       # Shopping cart
â”‚       â””â”€â”€ theme.svelte.ts      # Theme settings
```



### 2. **Provide Reset Functions**

```typescript
const initialState = {
    items: [],
    total: 0
};

const cart = $state({ ...initialState });

export function resetCart() {
    Object.assign(cart, initialState);
}
```

### 3. **Document Side Effects**

```typescript
/**
 * User preferences store
 * 
 * Side effects:
 * - Automatically persists to localStorage on change
 * - Applies theme to document.documentElement
 */
const preferences = $state({ theme: 'light' });
```

---

## ğŸ“ Key Takeaways

- âœ… Use `$effect.root()` to create global effects for shared state
- âœ… Global effects run regardless of component lifecycle
- âœ… Perfect for localStorage persistence and logging
- âœ… Always check for `window` in SSR environments
- âœ… Be careful of infinite loops and memory leaks
- âœ… Clean up effects when they're no longer needed

---

## ğŸš€ Next Steps

Ready to explore advanced features?

- **[Advanced Universal Reactivity Patterns](./03.%20Advanced%20Universal%20Reactivity%20Patterns.md)**: Learn about `$effect.tracking()`, `createSubscriber`, and reactive window properties

---

**You now know how to create global effects and persist state! Let's explore advanced patterns! ğŸ¯**
