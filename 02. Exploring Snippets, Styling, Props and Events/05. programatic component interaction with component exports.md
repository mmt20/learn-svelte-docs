# Programmatic Component Interaction

While Svelte encourages a declarative approach using props and state, there are times when you need to interact with a component imperatively. This is achieved by exposing properties or methods using the `export` keyword.

## 1. Exposing Methods and State

To make a variable or function accessible to a parent component, simply prefix it with the `export` keyword inside your `<script>` tag.

**Modal.svelte**
```html
<script lang="ts">
  let isOpen = $state(false);

  // Exposing a method
  export function open() {
    isOpen = true;
  }

  // Exposing a method
  export function close() {
    isOpen = false;
  }

  // Exposing state (read-only by default from outside)
  export const status = $derived(isOpen ? 'open' : 'closed');
</script>

{#if isOpen}
  <div class="modal">
    <p>I am a modal!</p>
    <button onclick={close}>Close</button>
  </div>
{/if}
```

## 2. Using `bind:this`

The parent component can capture a reference to the child component instance using the `bind:this` directive. This reference provides access to all exported members.

**App.svelte**
```html
<script lang="ts">
  import Modal from './Modal.svelte';

  // The type of the component instance
  let modalRef: ReturnType<typeof Modal>;
</script>

<button onclick={() => modalRef.open()}>
  Open Modal Programmatically
</button>

<Modal bind:this={modalRef} />

<p>The modal is currently: {modalRef?.status}</p>
```

## 3. When to use Exports?

Interacting with components via exports should be used sparingly. Most communication should happen via **Props** (data down) and **Callbacks** (events up).

### Good Use Cases:
- **Imperative UI Actions**: Opening/closing a modal, focusing an input, or triggering an animation.
- **Complex Internal State**: When a component manages complex internal logic that would be too cumbersome to sync entirely via props.
- **Third-Party Library Wrappers**: When wrapping a vanilla JS library that requires imperative method calls.

### Bad Use Cases:
- **Syncing Data**: If you find yourself calling `component.updateData(newData)`, you should probably be using a reactive prop instead.
- **Triggering Logic**: If a parent needs to know when something happens, use a callback prop (e.g., `onchange`) rather than the parent polling an exported value.

## 4. TypeScript Support

As shown in the example, you can get full type safety for your component references using `ReturnType<typeof ComponentName>`. This ensures that your IDE knows exactly which methods and properties are available on the instance.

```typescript
let myComponent: ReturnType<typeof MyComponent>;
```

## 6. Dynamic Rendering with `<svelte:element>`

Sometimes you need to decide which HTML tag to use at runtime based on a prop or state. Instead of writing a long `{#if}` block, you can use the `<svelte:element>` special tag.

### Basic Usage

The `this` attribute determines which tag is rendered. If `this` is null or undefined, nothing is rendered.

```html
<script>
  let { tag = 'div', children } = $props();
</script>

<svelte:element this={tag}>
  {@render children()}
</svelte:element>
```

### Advanced Example: A Dynamic "Heading" Component

This is perfect for components that could be an `h1`, `h2`, `h3`, etc., depending on the context.

```html
<script lang="ts">
  interface HeadingProps {
    level: 1 | 2 | 3 | 4 | 5 | 6;
    children: import('svelte').Snippet;
  }

  let { level, children }: HeadingProps = $props();
  let tag = $derived(`h${level}`);
</script>

<svelte:element this={tag} class="custom-heading">
  {@render children()}
</svelte:element>

<style>
  .custom-heading {
    font-family: 'Serif';
    color: darkblue;
  }
</style>
```

### Key Considerations:
1.  **Reactive `this`**: If the `this` value changes, Svelte will destroy the old element and create a new one.
2.  **Attributes & Bindings**: You can use standard attributes, event listeners, and even `bind:this` on `<svelte:element>`, just like a normal tag.
3.  **Invalid Tags**: If you pass a string that isn't a valid HTML tag name, the browser will likely treat it as a custom element or a div-like container (depending on the browser's fallback logic).

## 7. Summary

- **Expose**: Use `export` inside the child component.
- **Capture**: Use `bind:this` in the parent component.
- **Invoke**: Call methods or read properties on the captured reference.
- **Priority**: Always prefer declarative props/callbacks over imperative exports when possible.
