# Styling in Svelte

Svelte provides a robust, built-in styling system that emphasizes isolation and simplicity, while remaining compatible with powerful tools like SASS.

## 1. Scoped CSS (Default)

In Svelte, `<style>` tags are **scoped** by default. This means the styles you write inside a component will only apply to the HTML elements *within that same component*.

```html
<p>I am styled locally!</p>

<style>
  p {
    color: purple; /* Only affects <p> tags in this file */
  }
</style>
```

Svelte achieves this by adding a unique class (e.g., `svelte-xyz123`) to your elements at compile time.

## 2. Global Styling

Sometimes you need to break out of the scope. Svelte provides two ways to do this:

### The `:global(...)` Modifier
Use this to apply a style to an element or class globally, or to target children components.

```html
<style>
  /* Global for the entire app */
  :global(body) {
    background-color: #f0f0f0;
  }

  /* Target all <span> elements inside this component, even in children */
  .container :global(span) {
    font-weight: bold;
  }
</style>
```

### Global Stylesheets
For truly global styles (fonts, resets, variables), it's best to link a standard CSS file in your `app.html` or import it in your main entry point (e.g., `main.ts`).

## 3. Dynamic Classes

Svelte makes it easy to toggle classes based on reactive state.

### Using Ternaries/Expressions
```html
<script>
  let isActive = $state(false);
</script>

<button class={isActive ? 'active' : 'inactive'} onclick={() => isActive = !isActive}>
  Toggle
</button>
```

### The `class:` Directive (Preferred)
This is a cleaner shorthand for toggling classes. The class is applied only if the expression evaluates to true.

```html
<script>
  let isAdmin = $state(true);
  let isLogged = $state(true);
</script>

<!-- If 'isAdmin' is true, the 'red' class is added -->
<div class:red={isAdmin} class:bold={isLogged}>
  Admin Dashboard
</div>

<!-- Shorthand: if the variable name matches the class name -->
<div class:isAdmin>
  Welcome, Admin
</div>
```

## 4. Using SASS

To use SASS in Svelte, you simply need to add `lang="scss"` to your style tag.

> [!NOTE]
> This requires `svelte-preprocess` or the standard Svelte Vite plugin and the `sass` package to be installed in your project.

```html
<script>
  let theme = $state('dark');
</script>

<div class="container" class:dark={theme === 'dark'}>
  <h1>SASS in Svelte</h1>
</div>

<style lang="scss">
  $primary-color: #ff3e00;

  .container {
    padding: 2rem;

    h1 {
      color: $primary-color;
      font-family: 'Inter', sans-serif;
    }

    /* Nested Global */
    &.dark {
      background: #333;
      :global(button) {
        border-color: white;
      }
    }
  }
</style>
```

## 5. Handling Complex Classes with `clsx`

For components with many conditional classes, especially when using utility-first frameworks like Tailwind, the `class:` directive can become verbose. The `clsx` (or `classnames`) library is the standard way to handle this cleanly.

### Why use `clsx`?
It allows you to define classes using objects, arrays, and conditional logic in a single, readable string.

```html
<script>
  import clsx from 'clsx';
  
  let { variant = 'primary', size = 'md', isDisabled = false } = $props();

  // The "New way" to construct complex class lists
  let classes = $derived(clsx(
    'btn-base',
    {
      'btn-primary': variant === 'primary',
      'btn-secondary': variant === 'secondary',
      'btn-large': size === 'lg',
      'opacity-50 cursor-not-allowed': isDisabled
    }
  ));
</script>

<button class={classes}>
  Click Me
</button>
```

### Benefits in Svelte 5
By combining `clsx` with `$derived`, Svelte 5 ensures that your class string is only recalculated when one of its dependencies changes, keeping your DOM updates extremely efficient.

## 6. Passing Classes through Components

Since Svelte styles are scoped, you cannot directly style a child component from a parent using CSS selectors unless you use `:global()`. The standard way to allow parents to style a child's wrapper is by passing a `class` prop.

### The Problem: Scoped Styles
If you try to style `<Child class="my-style" />` in your parent's CSS, Svelte will remove the unused `.my-style` class because it doesn't see a local element using it.

### The Solution: The `class` Prop Pattern
Accept a `class` prop in the child and append it to the internal element.

**Component (Button.svelte)**
```html
<script>
  // Receive 'class' as a prop
  let { class: className, children } = $props();
</script>

<button class={className}>
  {@render children()}
</button>
```

**App.svelte (Parent)**
```html
<Button class="large-btn">Submit</Button>

<style>
  /* Use :global() to target the class if it's passed down */
  :global(.large-btn) {
    padding: 20px 40px;
    font-size: 1.5rem;
  }
</style>
```

> [!TIP]
> Use `clsx` to combine your component's base classes with the classes passed from the parent:
> `let classes = $derived(clsx('btn-base', className));`

## 7. Summary Table

| Feature | Syntax | Best Use Case |
| :--- | :--- | :--- |
| **Scoped** | `<style>` | Standard component styling (90% of cases) |
| **Global** | `:global(.class)` | Theming, third-party libraries, global resets |
| **Dynamic** | `class={active ? 'a' : 'b'}` | Simple binary state toggles |
| **Directive** | `class:active={state}` | Complex condition-based class lists |
| **SASS** | `<style lang="scss">` | When you need variables, nesting, or mixins |
