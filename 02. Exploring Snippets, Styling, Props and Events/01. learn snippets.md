# Snippets and Render Tags

Svelte 5 introduces **Snippets**, a powerful way to reuse snippets of HTML within your components. They replace most use-cases for slots with a more flexible, JavaScript-like syntax.

## 1. What are Snippets?

Snippets are essentially "mini-templates" defined inside your script or markup. They allow you to define a piece of UI once and render it multiple times, even passing data into it.

### Basic Syntax

You define a snippet using the `$snippet` keyword:

```html
{#snippet hello()}
	<p>Hello, world!</p>
{/snippet}
```

And you render it using the `{@render ...}` tag:

```html
{@render hello()}
```

## 2. Snippets with Parameters

One of the biggest advantages of snippets is the ability to pass parameters, making them truly dynamic.

```html
{#snippet userCard(name, role)}
	<div class="card">
		<h3>{name}</h3>
		<p>Role: {role}</p>
	</div>
{/snippet}

{@render userCard("Alice", "Developer")}
{@render userCard("Bob", "Designer")}
```

## 3. Why use Snippets vs. Components?

- **Local Reuse**: If you only need a piece of UI within a single component, a snippet is much lighter than creating a separate file.
- **Context Access**: Snippets have access to the variables in the scope where they are defined, unlike components which require explicit prop passing.
- **Performance**: Snippets are extremely efficient as they are compiled away into simple template functions.

## 4. Passing Snippets as Props

In Svelte 5, snippets are "first-class citizens." This means you can pass them as props to extra components, enabling advanced patterns like custom list item templates or flexible layouts.

### Named Snippets as Props

You can pass multiple snippets to a component by defining them inside the component's tags.

**Layout.svelte (The consumer)**
```html
<script>
    let { header, footer, children } = $props();
</script>

<div class="layout">
    <header>{@render header()}</header>
    <main>{@render children()}</main>
    <footer>{@render footer()}</footer>
</div>
```

**App.svelte (The provider)**
```html
<Layout>
    {#snippet header()}
        <h1>Welcome to my Site</h1>
    {/snippet}

    <p>This is the main content (passed to children).</p>

    {#snippet footer()}
        <p>Â© 2024 My Company</p>
    {/snippet}
</Layout>
```

### Passing Snippets via Attributes

You can also pass a snippet reference directly as an attribute:

```html
{#snippet mySnippet()}
    <span>I am a snippet!</span>
{/snippet}

<MyComponent iconSnippet={mySnippet} />
```

> [!TIP]
> Snippets are especially useful for repetitive UI elements like buttons, inputs, or cards that share logic but need slightly different markup in different places.

### Component Snippets with Arguments

One of the most powerful patterns in Svelte 5 is passing a snippet that expects arguments to a component. This allows the component to provide data (like an individual item in a list) back to the snippet for rendering.

**List.svelte (The consumer)**
```html
<script>
    let { items, children } = $props();
</script>

<ul>
    {#each items as item}
        {@render children(item)}
    {/each}
</ul>
```

**App.svelte (The provider)**
```html
<script>
    let users = [{ name: 'Alice' }, { name: 'Bob' }];
</script>

<List items={users}>
    {#snippet children(user)}
        <li><strong>User:</strong> {user.name}</li>
    {/snippet}
</List>
```

## 5. The "Children" Snippet

The most common use of snippets is the `children` snippet, which replaces the default `<slot />`. When you put content inside a component tag, it is automatically passed to the component as a snippet named `children`.

**Parent.svelte**
```html
<Child>
    <p>This is passed as the children snippet!</p>
</Child>
```

**Child.svelte**
```html
<script>
    let { children } = $props();
</script>

<div class="wrapper">
    {@render children?.()}
</div>
```

## 6. Real-World Example: Interactive Button

This example demonstrates how to create a highly flexible component that uses multiple snippets, internal state, and TypeScript for a robust developer experience.

### The Implementation

**App.svelte (The consumer)**
```html
<script lang="ts">
  import Button from "./Button.svelte";
  import { Search, CableIcon } from "@lucide/svelte"; // Assuming Lucide icons
</script>

<Button>
  {#snippet left(isHovered: boolean)}
    {#if isHovered}
      <Search style="color: red;" />
    {:else}
      <Search />
    {/if}
  {/snippet}

  {#snippet children(isLeftHovered: boolean)}
    {#if isLeftHovered}
      Left Hovered!
    {:else}
      Left not hovered
    {/if}
  {/snippet}

  {#snippet right()}
    <CableIcon />
  {/snippet}
</Button>
```

**Button.svelte (The component)**
```html
<script lang="ts">
  import type { Snippet } from "svelte";

  // Internal state to track interaction
  let isLeftHovered = $state(false);

  // Define the interface for snippets
  interface ButtonProps {
    left?: Snippet<[boolean]>;      // Accepts a boolean argument
    right?: Snippet;               // Simple snippet, no arguments
    children: Snippet<[boolean]>;  // Children also accepts a boolean
  }

  let { left, children, right }: ButtonProps = $props();
</script>

<button>
  {#if left}
    <span
      role="presentation"
      class="left-content"
      onmouseenter={() => isLeftHovered = true}
      onmouseleave={() => isLeftHovered = false}
    >
      <!-- Rendering 'left' and passing our internal state back to it -->
      {@render left(isLeftHovered)}
    </span>
  {/if}

  <!-- Rendering 'children' with the same state -->
  {@render children(isLeftHovered)}

  {#if right}
    <span class="right-content">
      {@render right()}
    </span>
  {/if}
</button>


```

### Breakdown of Key Concepts

#### 1. Circular Communication
This pattern allows for a "Parent -> Child -> Parent" flow:
1.  **Parent** defines *what* to render in snippets (`Search` icon, text).
2.  **Child** manages the *state* (`isLeftHovered`).
3.  **Child** passes that state *back* to the Parent's snippets via arguments.
4.  **Parent**'s snippets react to the Child's state and change their appearance.

#### 2. TypeScript Snippet Types
*   `Snippet`: A standard snippet that takes no arguments.
*   `Snippet<[boolean]>`: A snippet that expects a `boolean` argument. The types are defined as a tuple of the arguments' types.

#### 3. Why This is Powerful
Notice that `Button.svelte` has no idea what a "Search" icon is or what the text should say. It only knows that it has a "left" area, an "action" area (children), and a "right" area. It handles the layout and the interactivity logic, while giving the user total control over the UI content.

#### 4. The `children` Snippet as a Function
Even the main content (`children`) can be a function! Here, we use it to show different text based on whether the icon is being hovered, all while maintaining clean separation of concerns.
