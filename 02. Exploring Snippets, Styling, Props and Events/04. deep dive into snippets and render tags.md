# Deep Dive: Advanced Snippet Patterns

Snippets and render tags are the most significant change to Svelte's templating system. This deep dive explores patterns that enable extreme flexibility and type safety.

## 1. The Power of `{@render}`

The `{@render}` tag is not just for snippets defined in the same file. It is a universal way to "execute" a UI template passed from anywhere.

### Optional Rendering
Use the optional chaining operator (`?.`) when rendering snippets that might not be provided.

```html
<script>
  let { title, description } = $props();
</script>

<h1>{@render title()}</h1>

{#if description}
  {@render description()}
{/if}

<!-- Or the shorthand -->
{@render description?.()}
```

## 2. Snippets as First-Class Citizens

Because snippets are actually functions under the hood, you can store them in arrays, pass them through multiple layers of components, and even dynamically switch between them.

```html
<script>
  let { items, renderItem } = $props();
</script>

{#each items as item}
  <div class="card">
    {@render renderItem(item)}
  </div>
{/each}
```

## 3. High-Order Snippets

You can create snippets that wrap other snippets, allowing for powerful "decorator" patterns.

```html
{#snippet boldWrapper(innerSnippet, ...args)}
  <strong>
    {@render innerSnippet(...args)}
  </strong>
{/snippet}

{#snippet myText(name)}
  <span>Hello {name}</span>
{/snippet}

{@render boldWrapper(myText, "Alice")}
```

## 4. Performance & The Compiler

Snippets are more efficient than components for small, repetitive UI pieces because:
1.  **No Component Instance**: They don't have the overhead of a full component lifecycle (no `onMount`, no internal state).
2.  **Inlined Logic**: Svelte compiles snippets into highly optimized functions that directly manipulate the DOM.
3.  **Scope Sharing**: They share the same reactive scope as their parent, reducing the complexity of state management.

## 5. Type Safety with `Snippet`

Always use the `Snippet` type for props to ensure your components are used correctly.

```typescript
import type { Snippet } from 'svelte';

interface Props {
  // A simple snippet
  header: Snippet;
  
  // A snippet that takes a string and a number
  itemTemplate: Snippet<[string, number]>;
  
  // An optional snippet
  footer?: Snippet;
}
```

## 6. Best Practices

- **Use Snippets for Local Reuse**: If you find yourself repeating the same 10 lines of HTML in one component, make it a snippet.
- **Use Components for Global Reuse**: If you need the UI in multiple files, use a separate `.svelte` component.
- **Avoid Over-parameterization**: If a snippet takes 10 arguments, it might be trying to do too much. Consider breaking it down.
- **Leverage the `children` Snippet**: It's the cleanest way to pass primary content to components.
