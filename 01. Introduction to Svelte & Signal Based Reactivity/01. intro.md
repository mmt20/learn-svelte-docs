# Introduction to Svelte & Signal-Based Reactivity

## What is Svelte?

Svelte provides a way to build declarative, state-driven user interfaces. It uses a compiler to turn declarative components written in HTML, CSS, and JavaScript into lean, tightly optimized JavaScript.

Unlike traditional frameworks that do the bulk of their work in the browser, Svelte shifts that work into a **compile step**.

### Key Differences

*   **No Virtual DOM:** Svelte compiles your code into small, framework-free vanilla JavaScript modules.
*   **Truly Reactive:** Svelte puts reactivity into the JavaScript language itself using **Runes**.
*   **Less Boilerplate:** Write less code to achieve the same result.

## Signal-Based Reactivity with Runes

Svelte has a powerful system of reactivity for keeping the DOM in sync with your application state using a set of symbols called **Runes**.

Runes are symbols that you use in `.svelte` (and `.js`/`.ts`) files to declare state, derived values, side effects, and more.

### Universal Reactivity
Runes unlock **fine-grained reactivity** that is not limited to components. You can declare pieces of state in normal JavaScript/TypeScript modules outside of your components, allowing for powerful global state management patterns without external libraries.

### The Dependency Graph

Svelte's reactivity can be visualized as a flow of data:

1.  **State (Source):** The root of reactivity. Depends on nothing. It is **Writable**. (e.g., `$state`)
2.  **Derived:** Computed values based on state. Depends on sources. It is **Read-only**. (e.g., `$derived`)
3.  **Effect:** Side effects that run when dependencies change. Depends on sources and derived values. Nothing depends on it. (e.g., `$effect`)

## How Svelte Updates the DOM

Because Svelte is a compiler, it knows *exactly* which parts of the DOM depend on which pieces of state.

When you update a signal (like `count`), Svelte doesn't need to re-render the entire component or compare a Virtual DOM tree. Instead, it surgically updates only the specific text node or attribute that relies on that value.

## Example: Runes in Action

Here is an example showing how the pieces fit together:

```html
<script>
	let count = $state(0);
	// Derived value: automatically updates when 'count' changes
	let double = $derived(count * 2);

	// Effect: runs whenever 'count' or 'double' changes
	$effect(() => {
		console.log('from effect', count, double);
	});

	function increment() {
		count += 1;
		// Note: 'double' is updated automatically, but JS execution order matters 
		// if accessing it immediately in the same tick depending on context.
		// However, for logs inside functions, you see the current value.
		console.log('from increment', count, double);
	}
</script>

<button onclick={increment}>
	Count: {count}
</button>
```

### Breakdown of Runes

*   **`$state`**: Declares reactive state.
*   **`$derived`**: Creates a value that updates automatically when its dependencies change.
*   **`$effect`**: Runs code when dependencies change (useful for logs, analytics, or direct DOM manipulation).
*   **`$props`**: Declares inputs for a component.
