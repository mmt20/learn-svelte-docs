# Deep Dive into Signal-Based Reactivity

Svelte 5 introduces a fine-grained, signal-based reactivity model. This system creates a direct dependency graph between your data and the DOM, ensuring that only the absolute minimum amount of work is done when state changes.

## 1. The Mental Model

The system is built on three core primitives that flow in a specific direction:

### Sources (State)
Values that are both readable and writable. They form the "roots" of the dependency graph. They have no dependencies themselves but notify consumers when they change.
*   **Rune:** `$state(value)`

### Derived Values
Read-only computations based on state or other derived values. They act as intermediate "nodes" in the graph.

#### 1. Syntax Variations
*   **Expression:** `$derived(count * 2)` — Best for simple one-liners.
*   **Function:** `$derived.by(() => { ... })` — Best for complex logic requiring multiple lines.

#### 2. Why use Derived vs. Normal Functions?

Consider this scenario where we use the full name in multiple places:

**Option A: Raw Function (Inefficient)**
Every time the component renders or dependencies change, this function executes **3 times** (once for each usage).

```javascript
function getFullName() {
    console.log("Running calculation..."); // Runs 3x per update!
    return `${firstName} ${lastName}`;
}
```

```html
<h1>{getFullName()}</h1>
<img alt={getFullName()} />
<title>{getFullName()}</title>
```

**Option B: Derived Value (Efficient)**
Here, the calculation runs **once**. Svelte caches the result and reuses it for all 3 usages. It only recalculates if `firstName` or `lastName` changes.

```javascript
// Runs 1x per update
let fullName = $derived(`${firstName} ${lastName}`);
```

```html
<h1>{fullName}</h1>
<img alt={fullName} />
<title>{fullName}</title>
```

#### 3. Rules of Derivation
1.  **Synchronous**: Derived values are updated immediately when their dependencies change (if observed).
2.  **Pure Functions**: Your derivation logic must be **pure**.
    *   **No Side Effects**: Do not make API calls, set timeouts, or mutate other state inside a derived function.
    *   **Why?**: Because of **Pruning**, the function *might not run at all* if no one is listening. relying on side-effects here leads to bugs.
3.  **Read-Only (Default)**: You cannot assign to a derived value directly (e.g., `fullName = '...'` throws an error).

> [!NOTE]
> **Svelte 5.25 Update:** You can now create [writable derived values](https://svelte.dev/docs/svelte/$derived#Overriding-derived-values) by providing both a getter and a setter function to `$derived.by`.

### Reactions (Effects)
Side effects that run in response to source changes. These are the "leaves" of the graph that sync state with the outside world (DOM updates, console logs, network requests).
*   **Rune:** `$effect(fn)`
*   **Timing:** Scheduled on the microtask queue (runs asynchronously after state updates).

## 2. The Runtime: Dynamic Dependency Graphs

One of the most powerful features of Svelte's reactivity is that dependencies are tracked **dynamically at runtime**, not statically at compile time.

### How the Graph Rebuilds
The dependency graph is distinct because it is **rebuilt effectively every time an effect runs**. This is not an exaggeration—it is a core mechanism for correctness and performance.

1.  **Preparation**: Before an effect runs, Svelte effectively "wipes" its current list of dependencies. The effect enters a clean state.
2.  **Execution**: The effect function executes line by line.
3.  **Tracking**: As the code runs, every time a reactive value (signal or derived) is **read**, it registers itself as a dependency of the currently running effect.
4.  **Completion**: Once the function finishes, only the values that were *actually accessed* during that specific run are kept as dependencies.

### Why this matters (Senior Dev Insight)
This "Clean Slate" approach handles branching logic (`if`, `switch`, ternaries) automatically. You never have to manually unsubscribe or worry about "stale dependencies" where an effect re-runs for data it no longer uses.

If your code path changes (e.g., an `if` block swaps from `true` to `false`), the dependencies inside the `false` block are instantly pruned from the graph. They will strictly **never** trigger the effect again until the logic path directs execution back to them.

## 3. Visualizing with Code

Let's look at a concrete example to see this pruning in action.

```html
<script lang="ts">
  // Note: 'derived' import is from legacy stores, not used here for Runes ($derived)
  import { derived } from "svelte/store";

  
  let firstName: string =$state("Mostafa");
  let lastName: string = $state("Mohamed");
  
  let fullName:string = $derived.by(() => {
    // This log helps us verify if it runs!
    console.log("fullName derived recalculated");
    return `${firstName} ${lastName}`;
  });

  let username =$state("mostafa_dev");
  let bio = "Hello,<b> this is Mostafa</b>, a web developer.";


  $effect(() => {
    if(username || fullName){
      console.log("DisplayName updated:", username || fullName);
    }
  });
  
</script>
<div>
  <input type="text" bind:value={firstName} >
  <input type="text" bind:value={lastName} >
</div>
<input type="text" bind:value={username} >

<h1>{username || fullName}</h1>
<!-- <img src={src} alt="Avatar" width="150" height="150" /> -->
<p>{@html bio}</p>
<style>
  h1 {
    color: lightcoral;
    font-size: 24px;
    font-family: Arial, sans-serif;
  }
</style>
```

### Execution Analysis

**Scenario: `username` has a value ("mostafa_dev")**

1.  **The Effect**:
    *   Runs: `username || fullName`.
    *   `username` is "mostafa_dev" (Truth). The expression short-circuits.
    *   `fullName` is **skipped**.
    *   **Result**: The effect strictly depends ONLY on `username`.

2.  **The `<h1>`**:
    *   Same logic: `{username || fullName}`.
    *   Short-circuits. Only depends on `username`.

3.  **The Result (Dormancy)**:
    *   **NO** part of the application is reading `fullName`.
    *   Svelte marks `fullName` as **dormant**.
    *   **Verification**: If you open your console and type into the `firstName` or `lastName` inputs, **you will NOT see "fullName derived recalculated"**.
    *   Svelte creates the signals for `firstName` and `lastName`, but since `fullName` isn't listening, the derivation function doesn't run.

**Scenario: Clearing `username`**

1.  If you delete the text in the `username` input (make it empty string):
    *   `h1` update triggers: `"" || fullName` -> Reads `fullName`.
    *   `fullName` wakes up!
    *   It sees `firstName` changed, so it runs the derivation.
    *   **Console Log**: "fullName derived recalculated" appears.
    *   It returns the value, and the H1 updates.


## 4. Anti-Patterns & Pitfalls

### Pitfall 1: Using Effects to Derive Value (The Timing Trap)
**NEVER use effects to synchronize state.** Effects run asynchronously (in a microtask), while derived values run synchronously.

#### The Problem: Stale State
If you try to "manually derive" a value using an effect, it will be outdated if you access it immediately.

```html
<script lang="ts">
  let randomNumber = $state(Math.floor(Math.random() * 10));
  
  // BAD: Manual state sync (undefined initially)
  let doubleRandomNumber = $state();

  // Effects run asynchronously (microtask)
  $effect(() => {
    doubleRandomNumber = randomNumber * 2;
  });
</script>

<h2>Random Number is : {randomNumber}</h2>
<h2>Doubled Random Number is : {doubleRandomNumber}</h2>

<button onclick={()=>{
  // 1. Update State
  randomNumber = Math.floor(Math.random() * 10);
  
  // 2. Log Immediately
  // FAILURE: 'doubleRandomNumber' is still the OLD value!
  // The effect has not run yet. 
  console.log("======>", randomNumber, doubleRandomNumber);
}}>Generate</button> 
```

#### The Solution: Use `$derived`
Simply switch to `$derived`. It updates synchronously, so `doubleRandomNumber` is guaranteed to be fresh the moment `randomNumber` changes.

### Pitfall 2: Async Reactivity
A critical consequence of the synchronous **Derivation Stack** is that dependency tracking stops when you `await`.

```javascript
$effect(async () => {
    // 1. Synchronous phase: This IS tracked
    console.log(`User: ${username}`); 

    const data = await fetch(`/api/user/${username}`);

    // 2. Asynchronous phase: This is NOT tracked!
    console.log(`Full Name: ${fullName}`); 
});
```

**The Trap**: If `fullName` changes later, **this effect will NOT re-run**. Svelte only knows about dependencies accessed *before* the first `await`.

### Pitfall 3: State Accumulation (History)
You might be tempted to use `$effect` to "accumulate" values over time (e.g., maintaining a history log). This is dangerous because reading the array to push to it creates a dependency cycle.

```html
<script lang="ts">
  import { untrack } from "svelte";

  let randomNumber = $state(Math.floor(Math.random() * 10));
  let doubleRandomNumber = $derived(randomNumber * 2);

  let history :number[]= $state([])

  /* 
     THE WRONG WAY (Infinite Loop Risk):
     $effect(() => {
        // Reads history -> mutations trigger effect -> Reads history...
        history.push(randomNumber); 
     });
     
     THE COMPLEX WAY (Using untrack):
     $effect(() => {
       // We read 'randomNumber' (track it)
       // We DO NOT track 'history'
       untrack(() => history.push(randomNumber));
     });
  */
</script>

<h2>Random Number: {randomNumber} </h2>
<p>History: {history.join(', ')}</p>

<button onclick={()=>{
  // THE RIGHT WAY: Update directly in the event!
  randomNumber = Math.floor(Math.random() * 10);
  history = [...history, randomNumber];
  
  console.log("State updated:", randomNumber);
}}>Generate</button>
```

**Why avoids effects here?**
1.  **Complexity**: You essentially need `untrack` to avoid loops or over-firing.
2.  **Timing**: Effects run later. Events run now.
3.  **Simplicity**: If the user clicked a button, update the state IN the button handler. Use effects only for things that *must* happen automatically (like analytics logging or DOM interop) regardless of the source.

## 5. Resource Management: Lifecycles & Cleanup

Effects are the standard place to set up resources like intervals, event listeners, or subscriptions. Because effects re-run when dependencies change, Svelte provides a **Cleanup Function** to prevent memory leaks.

```html
<script lang="ts">
  let count = $state(0);
  let frequency = $state(1000);
  let paused = $state(false);

  $effect(() => {
    // 1. Setup Phase
    let interval: number;
    
    // Track dependencies: 'paused' and 'frequency' are read synchronously.
    if (!paused) {
      interval = setInterval(() => {
        // 'count' is read inside the callback (Asynchronously).
        // It is NOT tracked by the effect! 
        // This is GOOD. If it were tracked, we'd have an infinite loop!
        console.log(count);
        count += 1;
      }, frequency);
    }

    // 2. Cleanup Phase
    // This function runs BEFORE the effect re-runs (or component destroys).
    return () => {
      console.log("Cleanup: clearing interval");
      clearInterval(interval);
    };
  });
</script>

<h1>Counter : {count}</h1>
{frequency} ms

<button onclick={() => paused = !paused}>
  {paused ? "Resume" : "Pause"}
</button>

<button
  onclick={() => {
    count = 0;
    // Attempting to force a restart by toggling frequency
    const _originalFrequency = frequency;
    frequency = 0;
    frequency = _originalFrequency;
  }}>Reset</button>

<button onclick={() => frequency *= 2}>Slower</button>
<button onclick={() => frequency /= 2}>Faster</button> 
```

### The "Reset" Mystery: Why the toggle?
You might wonder why we need this specific block in the Reset button:
```javascript
const _originalFrequency = frequency;
frequency = 0; 
frequency = _originalFrequency;
```

**If you ONLY did `count = 0`:**
1.  **No Tracking**: Remember, the effect only tracks `paused` and `frequency`. It **does not track** `count` because `count` is read asynchronously inside the `setInterval` closure.
2.  **No Dirty Flag**: Svelte sees that `paused` and `frequency` haven't changed. The effect is NOT marked "dirty".
3.  **No Cleanup**: Because the effect doesn't re-run, the **Cleanup Function is never called**.
4.  **The Result**: The *old* `setInterval` continues to run in the background, unaware that you reset the count to zero.

**By toggling `frequency`**:
You are forcing Svelte to see a change in a **tracked dependency**. This forces the effect to enter its "Update Cycle," which triggers the **Cleanup Function** (clearing the old timer) and then re-runs the setup (starting a fresh timer). 

> [!TIP]
> This pattern is a way to "force restart" an effect when a non-tracked value changes. In complex apps, you might use a dedicated `$state` variable just for this purpose (like a `version` or `resetKey`).

## 6. Two-Way Binding: The `bind:` Directive

The `bind:` directive is Svelte's solution for two-way data binding. While it appears simple on the surface, understanding how it works internally reveals the elegance of Svelte's reactivity system.

### How `bind:` Works Under the Hood

When you write `bind:value={myVariable}`, Svelte creates **both a getter and a setter** to synchronize the DOM element with your state.

#### Without `bind:` (Manual Two-Way Binding)

```html
<script lang="ts">
  let username = $state("");
</script>

<!-- Manual approach: verbose and error-prone -->
<input 
  type="text" 
  value={username}
  oninput={(e) => username = e.currentTarget.value}
/>
```

**What's happening:**
1. **Getter (value={username})**: Reads the current state and sets the input's value.
2. **Setter (oninput handler)**: Listens for changes and updates the state.

#### With `bind:` (Automatic Two-Way Binding)

```html
<script lang="ts">
  let username = $state("");
</script>

<!-- Svelte handles both getter and setter automatically -->
<input type="text" bind:value={username} />
```

**What Svelte generates internally:**
- **Getter**: Automatically reads `username` and sets `input.value`.
- **Setter**: Automatically listens to the `input` event and updates `username`.

### The Getter/Setter Mechanism

Think of `bind:` as creating a **synchronized connection** between your state and the DOM:

```javascript
// Conceptual representation (not actual Svelte code)
Object.defineProperty(inputElement, 'value', {
  // GETTER: DOM reads from state
  get() {
    return username;
  },
  
  // SETTER: DOM writes to state
  set(newValue) {
    username = newValue;
  }
});
```

This creates a **reactive loop**:
1. When `username` changes → Input value updates (getter)
2. When user types → `username` updates (setter)
3. When `username` updates → Any derived values or effects re-run

### Common `bind:` Use Cases

#### 1. Text Inputs

```html
<script lang="ts">
  let firstName = $state("John");
  let lastName = $state("Doe");
  
  let fullName = $derived(`${firstName} ${lastName}`);
</script>

<input type="text" bind:value={firstName} placeholder="First Name" />
<input type="text" bind:value={lastName} placeholder="Last Name" />

<p>Full Name: {fullName}</p>
```

#### 2. Checkboxes

```html
<script lang="ts">
  let agreed = $state(false);
  let newsletter = $state(true);
</script>

<label>
  <input type="checkbox" bind:checked={agreed} />
  I agree to the terms
</label>

<label>
  <input type="checkbox" bind:checked={newsletter} />
  Subscribe to newsletter
</label>

<p>Can submit: {agreed ? 'Yes' : 'No'}</p>
```

#### 3. Radio Buttons

```html
<script lang="ts">
  let selectedColor = $state("blue");
</script>

<label>
  <input type="radio" bind:group={selectedColor} value="red" />
  Red
</label>

<label>
  <input type="radio" bind:group={selectedColor} value="blue" />
  Blue
</label>

<label>
  <input type="radio" bind:group={selectedColor} value="green" />
  Green
</label>

<p>Selected: {selectedColor}</p>
```

#### 4. Select Dropdowns

```html
<script lang="ts">
  let country = $state("us");
  
  const countries = [
    { code: "us", name: "United States" },
    { code: "uk", name: "United Kingdom" },
    { code: "ca", name: "Canada" }
  ];
</script>

<select bind:value={country}>
  {#each countries as {code, name}}
    <option value={code}>{name}</option>
  {/each}
</select>

<p>Selected: {country}</p>
```

#### 5. Textarea

```html
<script lang="ts">
  let bio = $state("");
  let charCount = $derived(bio.length);
</script>

<textarea bind:value={bio} placeholder="Tell us about yourself..."></textarea>
<p>{charCount} / 500 characters</p>
```

#### 6. Number Inputs

```html
<script lang="ts">
  let age = $state(25);
  let price = $state(99.99);
</script>

<!-- bind:value automatically converts to number -->
<input type="number" bind:value={age} min="0" max="120" />
<input type="range" bind:value={age} min="0" max="120" />

<p>Age: {age}</p>
```

### Advanced: Binding to Component Props

You can also bind to component props using `bind:` with the `$bindable()` rune:

```html
<!-- Child.svelte -->
<script lang="ts">
  // Make this prop bindable from parent
  let { value = $bindable("") } = $props();
</script>

<input type="text" bind:value />

<!-- Parent.svelte -->
<script lang="ts">
  import Child from './Child.svelte';
  
  let parentValue = $state("");
</script>

<!-- Two-way binding between parent and child -->
<Child bind:value={parentValue} />
<p>Parent sees: {parentValue}</p>
```

### Performance Considerations

**Bind is efficient** because:
1. **No extra watchers**: Svelte doesn't create separate observers. It uses native DOM events.
2. **Granular updates**: Only the bound value updates, not the entire component.
3. **Compile-time optimization**: The getter/setter logic is generated at build time.

> [!WARNING]
> **Avoid binding to derived values**: You cannot `bind:` to a `$derived` value because derived values are read-only by default. If you need writable derived values, use `$derived.by()` with custom getter/setter logic (Svelte 5.25+).

### Key Takeaways

1. **`bind:` = Getter + Setter**: It creates a two-way synchronization between state and DOM.
2. **Automatic event handling**: Svelte chooses the right DOM event (`input`, `change`, etc.) based on the element type.
3. **Type conversion**: For `type="number"`, Svelte automatically converts strings to numbers.
4. **Works with components**: Use `$bindable()` to make component props bindable.
5. **Reactive by nature**: Changes flow through the entire reactivity graph automatically.
