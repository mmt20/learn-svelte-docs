# Deep Dive into Signal-Based Reactivity

Svelte 5 introduces a fine-grained, signal-based reactivity model. This system creates a direct dependency graph between your data and the DOM, ensuring that only the absolute minimum amount of work is done when state changes.

## 1. The Mental Model

The system is built on three core primitives that flow in a specific direction:

### Sources (State)
Values that are both readable and writable. They form the "roots" of the dependency graph. They have no dependencies themselves but notify consumers when they change.
*   **Rune:** `$state(value)`

### Derived Values
Read-only computations based on state or other derived values. They act as intermediate "nodes" in the graph.

#### 1. Syntax Variations
*   **Expression:** `$derived(count * 2)` — Best for simple one-liners.
*   **Function:** `$derived.by(() => { ... })` — Best for complex logic requiring multiple lines.

#### 2. Why use Derived vs. Normal Functions?

Consider this scenario where we use the full name in multiple places:

**Option A: Raw Function (Inefficient)**
Every time the component renders or dependencies change, this function executes **3 times** (once for each usage).

```javascript
function getFullName() {
    console.log("Running calculation..."); // Runs 3x per update!
    return `${firstName} ${lastName}`;
}
```

```html
<h1>{getFullName()}</h1>
<img alt={getFullName()} />
<title>{getFullName()}</title>
```

**Option B: Derived Value (Efficient)**
Here, the calculation runs **once**. Svelte caches the result and reuses it for all 3 usages. It only recalculates if `firstName` or `lastName` changes.

```javascript
// Runs 1x per update
let fullName = $derived(`${firstName} ${lastName}`);
```

```html
<h1>{fullName}</h1>
<img alt={fullName} />
<title>{fullName}</title>
```

#### 3. Rules of Derivation
1.  **Synchronous**: Derived values are updated immediately when their dependencies change (if observed).
2.  **Pure Functions**: Your derivation logic must be **pure**.
    *   **No Side Effects**: Do not make API calls, set timeouts, or mutate other state inside a derived function.
    *   **Why?**: Because of **Pruning**, the function *might not run at all* if no one is listening. relying on side-effects here leads to bugs.
3.  **Read-Only (Default)**: You cannot assign to a derived value directly (e.g., `fullName = '...'` throws an error).

> [!NOTE]
> **Svelte 5.25 Update:** You can now create [writable derived values](https://svelte.dev/docs/svelte/$derived#Overriding-derived-values) by providing both a getter and a setter function to `$derived.by`.

### Reactions (Effects)
Side effects that run in response to source changes. These are the "leaves" of the graph that sync state with the outside world (DOM updates, console logs, network requests).
*   **Rune:** `$effect(fn)`
*   **Timing:** Scheduled on the microtask queue (runs asynchronously after state updates).

## 2. The Runtime: Dynamic Dependency Graphs

One of the most powerful features of Svelte's reactivity is that dependencies are tracked **dynamically at runtime**, not statically at compile time.

### How the Graph Rebuilds
The dependency graph is distinct because it is **rebuilt effectively every time an effect runs**. This is not an exaggeration—it is a core mechanism for correctness and performance.

1.  **Preparation**: Before an effect runs, Svelte effectively "wipes" its current list of dependencies. The effect enters a clean state.
2.  **Execution**: The effect function executes line by line.
3.  **Tracking**: As the code runs, every time a reactive value (signal or derived) is **read**, it registers itself as a dependency of the currently running effect.
4.  **Completion**: Once the function finishes, only the values that were *actually accessed* during that specific run are kept as dependencies.

### Why this matters (Senior Dev Insight)
This "Clean Slate" approach handles branching logic (`if`, `switch`, ternaries) automatically. You never have to manually unsubscribe or worry about "stale dependencies" where an effect re-runs for data it no longer uses.

If your code path changes (e.g., an `if` block swaps from `true` to `false`), the dependencies inside the `false` block are instantly pruned from the graph. They will strictly **never** trigger the effect again until the logic path directs execution back to them.

## 3. Visualizing with Code

Let's look at a concrete example to see this pruning in action.

```html
<script lang="ts">
  // Note: 'derived' import is from legacy stores, not used here for Runes ($derived)
  import { derived } from "svelte/store";

  
  let firstName: string =$state("Mostafa");
  let lastName: string = $state("Mohamed");
  
  let fullName:string = $derived.by(() => {
    // This log helps us verify if it runs!
    console.log("fullName derived recalculated");
    return `${firstName} ${lastName}`;
  });

  let username =$state("mostafa_dev");
  let bio = "Hello,<b> this is Mostafa</b>, a web developer.";


  $effect(() => {
    if(username || fullName){
      console.log("DisplayName updated:", username || fullName);
    }
  });
  
</script>
<div>
  <input type="text" bind:value={firstName} >
  <input type="text" bind:value={lastName} >
</div>
<input type="text" bind:value={username} >

<h1>{username || fullName}</h1>
<!-- <img src={src} alt="Avatar" width="150" height="150" /> -->
<p>{@html bio}</p>
<style>
  h1 {
    color: lightcoral;
    font-size: 24px;
    font-family: Arial, sans-serif;
  }
</style>
```

### Execution Analysis

**Scenario: `username` has a value ("mostafa_dev")**

1.  **The Effect**:
    *   Runs: `username || fullName`.
    *   `username` is "mostafa_dev" (Truth). The expression short-circuits.
    *   `fullName` is **skipped**.
    *   **Result**: The effect strictly depends ONLY on `username`.

2.  **The `<h1>`**:
    *   Same logic: `{username || fullName}`.
    *   Short-circuits. Only depends on `username`.

3.  **The Result (Dormancy)**:
    *   **NO** part of the application is reading `fullName`.
    *   Svelte marks `fullName` as **dormant**.
    *   **Verification**: If you open your console and type into the `firstName` or `lastName` inputs, **you will NOT see "fullName derived recalculated"**.
    *   Svelte creates the signals for `firstName` and `lastName`, but since `fullName` isn't listening, the derivation function doesn't run.

**Scenario: Clearing `username`**

1.  If you delete the text in the `username` input (make it empty string):
    *   `h1` update triggers: `"" || fullName` -> Reads `fullName`.
    *   `fullName` wakes up!
    *   It sees `firstName` changed, so it runs the derivation.
    *   **Console Log**: "fullName derived recalculated" appears.
    *   It returns the value, and the H1 updates.


## 4. Anti-Patterns & Pitfalls

### Pitfall 1: Using Effects to Derive Value (The Timing Trap)
**NEVER use effects to synchronize state.** Effects run asynchronously (in a microtask), while derived values run synchronously.

#### The Problem: Stale State
If you try to "manually derive" a value using an effect, it will be outdated if you access it immediately.

```html
<script lang="ts">
  let randomNumber = $state(Math.floor(Math.random() * 10));
  
  // BAD: Manual state sync (undefined initially)
  let doubleRandomNumber = $state();

  // Effects run asynchronously (microtask)
  $effect(() => {
    doubleRandomNumber = randomNumber * 2;
  });
</script>

<h2>Random Number is : {randomNumber}</h2>
<h2>Doubled Random Number is : {doubleRandomNumber}</h2>

<button onclick={()=>{
  // 1. Update State
  randomNumber = Math.floor(Math.random() * 10);
  
  // 2. Log Immediately
  // FAILURE: 'doubleRandomNumber' is still the OLD value!
  // The effect has not run yet. 
  console.log("======>", randomNumber, doubleRandomNumber);
}}>Generate</button> 
```

#### The Solution: Use `$derived`
Simply switch to `$derived`. It updates synchronously, so `doubleRandomNumber` is guaranteed to be fresh the moment `randomNumber` changes.

### Pitfall 2: Async Reactivity
A critical consequence of the synchronous **Derivation Stack** is that dependency tracking stops when you `await`.

```javascript
$effect(async () => {
    // 1. Synchronous phase: This IS tracked
    console.log(`User: ${username}`); 

    const data = await fetch(`/api/user/${username}`);

    // 2. Asynchronous phase: This is NOT tracked!
    console.log(`Full Name: ${fullName}`); 
});
```

**The Trap**: If `fullName` changes later, **this effect will NOT re-run**. Svelte only knows about dependencies accessed *before* the first `await`.

### Pitfall 3: State Accumulation (History)
You might be tempted to use `$effect` to "accumulate" values over time (e.g., maintaining a history log). This is dangerous because reading the array to push to it creates a dependency cycle.

```html
<script lang="ts">
  import { untrack } from "svelte";

  let randomNumber = $state(Math.floor(Math.random() * 10));
  let doubleRandomNumber = $derived(randomNumber * 2);

  let history :number[]= $state([])

  /* 
     THE WRONG WAY (Infinite Loop Risk):
     $effect(() => {
        // Reads history -> mutations trigger effect -> Reads history...
        history.push(randomNumber); 
     });
     
     THE COMPLEX WAY (Using untrack):
     $effect(() => {
       // We read 'randomNumber' (track it)
       // We DO NOT track 'history'
       untrack(() => history.push(randomNumber));
     });
  */
</script>

<h2>Random Number: {randomNumber} </h2>
<p>History: {history.join(', ')}</p>

<button onclick={()=>{
  // THE RIGHT WAY: Update directly in the event!
  randomNumber = Math.floor(Math.random() * 10);
  history = [...history, randomNumber];
  
  console.log("State updated:", randomNumber);
}}>Generate</button>
```

**Why avoids effects here?**
1.  **Complexity**: You essentially need `untrack` to avoid loops or over-firing.
2.  **Timing**: Effects run later. Events run now.
3.  **Simplicity**: If the user clicked a button, update the state IN the button handler. Use effects only for things that *must* happen automatically (like analytics logging or DOM interop) regardless of the source.

## 5. Resource Management: Lifecycles & Cleanup

Effects are the standard place to set up resources like intervals, event listeners, or subscriptions. Because effects re-run when dependencies change, Svelte provides a **Cleanup Function** to prevent memory leaks.

```html
<script lang="ts">
  let count = $state(0);
  let frequency = $state(1000);
  let paused = $state(false);

  $effect(() => {
    // 1. Setup Phase
    let interval: number;
    
    // Track dependencies: 'paused' and 'frequency' are read synchronously.
    if (!paused) {
      interval = setInterval(() => {
        // 'count' is read inside the callback (Asynchronously).
        // It is NOT tracked by the effect! 
        // This is GOOD. If it were tracked, we'd have an infinite loop!
        console.log(count);
        count += 1;
      }, frequency);
    }

    // 2. Cleanup Phase
    // This function runs BEFORE the effect re-runs (or component destroys).
    return () => {
      console.log("Cleanup: clearing interval");
      clearInterval(interval);
    };
  });
</script>

<h1>Counter : {count}</h1>
{frequency} ms

<button onclick={() => paused = !paused}>
  {paused ? "Resume" : "Pause"}
</button>

<button
  onclick={() => {
    count = 0;
    // Attempting to force a restart by toggling frequency
    const _originalFrequency = frequency;
    frequency = 0;
    frequency = _originalFrequency;
  }}>Reset</button>

<button onclick={() => frequency *= 2}>Slower</button>
<button onclick={() => frequency /= 2}>Faster</button> 
```

### The "Reset" Mystery: Why the toggle?
You might wonder why we need this specific block in the Reset button:
```javascript
const _originalFrequency = frequency;
frequency = 0; 
frequency = _originalFrequency;
```

**If you ONLY did `count = 0`:**
1.  **No Tracking**: Remember, the effect only tracks `paused` and `frequency`. It **does not track** `count` because `count` is read asynchronously inside the `setInterval` closure.
2.  **No Dirty Flag**: Svelte sees that `paused` and `frequency` haven't changed. The effect is NOT marked "dirty".
3.  **No Cleanup**: Because the effect doesn't re-run, the **Cleanup Function is never called**.
4.  **The Result**: The *old* `setInterval` continues to run in the background, unaware that you reset the count to zero.

**By toggling `frequency`**:
You are forcing Svelte to see a change in a **tracked dependency**. This forces the effect to enter its "Update Cycle," which triggers the **Cleanup Function** (clearing the old timer) and then re-runs the setup (starting a fresh timer). 

> [!TIP]
> This pattern is a way to "force restart" an effect when a non-tracked value changes. In complex apps, you might use a dedicated `$state` variable just for this purpose (like a `version` or `resetKey`).
