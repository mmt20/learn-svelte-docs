# Svelte vs React

This guide compares Svelte (specifically Svelte 5 with Runes) and React, highlighting their fundamental differences in philosophy and execution.

## Core Philosophy

| Feature | Svelte | React |
| :--- | :--- | :--- |
| **Type** | **Compiler** | **Library** (Runtime) |
| **Rendering** | Surgical DOM updates | Virtual DOM Diffing |
| **Reactivity** | Fine-grained (Signals) | Component-level (Hooks) |
| **Bundle Size** | Smaller (no framework runtime) | Larger (needs React runtime) |

### 1. The React Model (Virtual DOM)
React detects changes by re-running your component function to create a new "Virtual DOM" tree. It then compares this new tree with the old one (diffing) and calculates the minimum set of DOM operations to update the real screen.
*   **Pros:** deeply understood patterns, vast ecosystem.
*   **Cons:** "Re-renders" can be expensive; requires `useMemo`/`useCallback` to optimize performance; dependency arrays can be tricky.

### 2. The Svelte Model (Compiler + Signals)
Svelte analyzes your code at **build time**. It compiles your components into imperative JavaScript that directly modifies the DOM when state changes.
*   **Pros:** "Truly reactive" â€” no VDOM overhead; performance is opt-in by default; simpler mental model (values just update).
*   **Cons:** Smaller ecosystem (though growing fast); build step is required (true for modern React too, effectively).

## Code Comparison: Counter

Let's look at how to implement a simple counter with a derived value (doubled count) and a side effect (logging).

### React (Hooks)

```javascript
import { useState, useMemo, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  // Derived state (memoized to prevent recalc on every render)
  const double = useMemo(() => count * 2, [count]);

  // Side Effect
  useEffect(() => {
    console.log(`Count is ${count}`);
  }, [count]); // Manual dependency array

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}, Double: {double}
    </button>
  );
}
```

### Svelte 5 (Runes)

```javascript
<script>
  let count = $state(0);
  
  // Derived state (automatically explicit dependencies)
  let double = $derived(count * 2);

  // Side Effect (automatically tracks dependencies)
  $effect(() => {
    console.log(`Count is ${count}`);
  });

  function increment() {
    count += 1;
  }
</script>

<button onclick={increment}>
  Count: {count}, Double: {double}
</button>
```

## Key Syntax mapping

| Concept | React Hook | Svelte Rune |
| :--- | :--- | :--- |
| **State** | `useState(val)` | `$state(val)` |
| **Derived** | `useMemo(() => val, [deps])` | `$derived(val)` |
| **Side Effect** | `useEffect(() => {}, [deps])` | `$effect(() => {})` |
| **Props** | `function Comp(props)` | `let props = $props()` |
| **Refs** | `useRef(null)` | `bind:this` / `$state()` |

## Summary

Svelte 5's Signal-based reactivity removes the "overhead" of React's component lifecycle. You don't need to worry about stale closures, dependency arrays, or `useCallback`. You declare *what* data is, and the Svelte compiler ensures the DOM stays in sync efficiently.
