# 04. Pitfalls and Best Practices for Load Functions

Load functions are the backbone of data fetching in SvelteKit. This document consolidates common pitfalls and best practices to help you build performant, maintainable applications.

---

## ðŸ†š Load Functions: SvelteKit vs Others

| Feature | React (Client-side) | SvelteKit (Load Functions) |
| :--- | :--- | :--- |
| **Execution** | Client-side only | Server-side + Client-side (Universal) |
| **Timing** | After component mount | Before component renders |
| **Waterfalls** | Frequent (if not careful) | Preventable with `Promise.all()` |

---

## âš ï¸ Common Pitfalls

### 1. Waterfall Requests
**Bad:** Sequential fetches slow down the page.
```js
const user = await fetch('/api/user').then(r => r.json());
const posts = await fetch(`/api/posts/${user.id}`).then(r => r.json()); // Waits for user
```
**Good:** Parallel fetches are faster.
```js
const [user, settings] = await Promise.all([
    fetch('/api/user').then(r => r.json()),
    fetch('/api/settings').then(r => r.json())
]);
```

### 2. Exposing Sensitive Data
**Bad:** Returning secrets from a universal load function (`+page.js`).
```js
export async function load() {
    return { apiKey: process.env.API_KEY }; // âŒ Exposed to client!
}
```
**Good:** Use server-only files (`+page.server.js`) and process data there.

### 3. Over-fetching Data
**Bad:** Loading 10,000 users for a dropdown.
**Good:** Filter on the server (`/api/users?limit=10&select=name`).

### 4. Blocking Rendering with Slow Requests
**Bad:** Making the user wait for non-critical data.
**Good:** Return the promise (Streaming) so the page loads while data comes later.
```js
return {
    streamed: fetch('https://slow-api.com').then(r => r.json())
};
```

### 5. Over-Invalidating
**Bad:** Calling `invalidateAll()` for minor updates.
```js
await fetch('/api/profile', { method: 'PUT', body: data });
await invalidateAll(); // âŒ Refreshes everything
```
**Good:** Invalidate only what changed.
```js
await invalidate('app:user'); // âœ… Specific
```

### 6. Forgetting to Await Invalidation
**Bad:** `invalidate('/api/data')` without `await` means the UI updates before data refreshes.
**Good:** `await invalidate('/api/data')` ensures the operation completes.

### 7. Missing Dependencies
**Bad:** Calling `invalidate('app:data')` when no load function `depends('app:data')`.
**Good:** Always declare dependencies in your load function:
```js
export async function load({ depends }) {
    depends('app:data');
}
```

### 8. Over-Preloading
**Bad:** Preloading every link on the page creates network congestion.
**Good:** Preload only critical routes (likely next destinations).

### 9. Preloading External Links
**Bad:** Trying to preload `https://google.com` (doesn't work and wastes resources).
**Good:** Set `data-sveltekit-preload-data="off"` for external links.

---

## ðŸ† Best Practices

### 1. Use TypeScript for Safety
Always type your load functions:
```ts
import type { PageLoad } from './$types';
export const load: PageLoad = async ({ fetch }) => { ... };
```

### 2. Fine-Grained Invalidation
Use descriptive names for custom dependencies (`app:user`, `posts:list`) and invalidate only what is necessary.

### 3. Use SvelteKit's `fetch`
Always use the `fetch` provided in the load arguments, not the global `window.fetch`. It handles cookies, credentials, and relative URLs correctly during server-side rendering.

### 4. Provide User Feedback
When performing manual invalidation or refreshing, show a loading state to the user.
```svelte
<button disabled={refreshing}>{refreshing ? 'Refreshing...' : 'Refresh'}</button>
```

### 5. Clean Up Intervals
If you use polling (setInterval), always clear the interval in `onDestroy` to prevent memory leaks.

### 6. Preload Strategically
- **Desktop:** Use `data-sveltekit-preload-data="hover"`
- **Mobile:** Use `data-sveltekit-preload-data="tap"`
- **Critical (Above Fold):** Use `data-sveltekit-preload-code="eager"` or `viewport`

---

## ðŸŽ¯ Quick Reference

| Scenario | Solution |
|:---------|:---------|
| **Sensitive secrets** | Use `+page.server.js` |
| **Parallel requests** | Use `Promise.all()` |
| **Slow API** | Return promise without `await` (streaming) |
| **Refresh data** | Use `invalidate('key')` or `invalidate(url)` |
| **Global refresh** | Use `invalidateAll()` (sparingly) |
| **Polling** | Use `setInterval` + `invalidate` (cleanup required) |

---

**You've mastered Load Functions! ðŸŽ‰**
