# 01. Load Functions Overview

Load functions are the primary way to fetch data for your pages and layouts in SvelteKit. They run before your component renders, ensuring data is available when the page displays.

---

## ğŸ¯ What Are Load Functions?

A **load function** is an exported function from a `+page.js`, `+page.server.js`, `+layout.js`, or `+layout.server.js` file. It fetches data and returns it to the corresponding Svelte component.

```javascript
// src/routes/blog/+page.js
export async function load({ fetch }) {
  const response = await fetch('https://dummyjson.com/posts');
  const data = await response.json();
  
  return { posts: data.posts };
}
```

```svelte
<!-- src/routes/blog/+page.svelte -->
<script>
  let { data } = $props();
</script>

<h1>Blog Posts</h1>
{#each data.posts as post}
  <article>
    <h2>{post.title}</h2>
    <p>{post.excerpt}</p>
  </article>
{/each}
```

---

## ğŸ“¦ Universal Load Functions (`+page.js`)

Universal load functions run on **both** the server (SSR) and the client (navigation).

### When They Run

| Scenario | Where Load Runs |
| :--- | :--- |
| First page visit (SSR) | Server |
| Client-side navigation | Client (browser) |
| After `invalidate()` | Client |

### File: `+page.js` or `+layout.js`

```javascript
// src/routes/products/+page.js
export async function load({ fetch, params, url }) {
  const category = url.searchParams.get('category') || 'smartphones';
  
  const response = await fetch(`https://dummyjson.com/products/category/${category}`);
  const data = await response.json();
  
  return { products: data.products, category };
}
```

### Key Characteristics

- âœ… Can run in the browser (client-side navigation)
- âœ… Has access to `fetch`, `params`, `url`, `route`
- âŒ Cannot access cookies, headers, or database directly
- âŒ Cannot use server-only modules (`$env/static/private`)

> [!IMPORTANT]
> Use `+page.js` when your data can be fetched from a public API endpoint. Use `+page.server.js` when you need server-only access (database, secrets).

---

## ğŸ”’ Server-Only Load Functions (`+page.server.js`)

Server load functions run **only** on the server. They're ideal for accessing databases, secrets, or performing authenticated operations.

### File: `+page.server.js` or `+layout.server.js`

```javascript
// src/routes/dashboard/+page.server.js
import { db } from '$lib/server/database';
import { error, redirect } from '@sveltejs/kit';

export async function load({ cookies, locals }) {
  // Access cookies (server-only)
  const sessionId = cookies.get('session');
  
  if (!sessionId) {
    throw redirect(303, '/login');
  }
  
  // Access database directly (server-only)
  const user = await db.user.findUnique({
    where: { sessionId }
  });
  
  if (!user) {
    throw error(401, 'Unauthorized');
  }
  
  const stats = await db.stats.findMany({
    where: { userId: user.id }
  });
  
  return { user, stats };
}
```

### Key Characteristics

- âœ… Access to `cookies`, `locals`, `platform`
- âœ… Can import from `$lib/server` and `$env/static/private`
- âœ… Direct database access
- âŒ Only runs on server (not during client navigation)
- âš¡ Client navigation fetches data via internal API call

### Server Load Context

| Property | Description |
| :--- | :--- |
| `cookies` | Read/write cookies |
| `locals` | Data set in `hooks.server.js` |
| `platform` | Platform-specific context (Cloudflare, Vercel, etc.) |
| `request` | The original Request object |
| `setHeaders` | Set response headers |

---

## ğŸ›¡ï¸ Zero-Effort Type Safety with Generated Types

SvelteKit automatically generates TypeScript types for your load functions. This provides **end-to-end type safety** from load function to component.

### How It Works

1. SvelteKit analyzes your `load` function return type
2. It generates types in `.svelte-kit/types`
3. Your component's `data` prop is automatically typed

### Using Generated Types

```typescript
// src/routes/blog/[slug]/+page.server.ts
import type { PageServerLoad } from './$types';
import { db } from '$lib/server/database';
import { error } from '@sveltejs/kit';

export const load: PageServerLoad = async ({ params }) => {
  const post = await db.post.findUnique({
    where: { slug: params.slug }
  });
  
  if (!post) {
    throw error(404, 'Post not found');
  }
  
  return { post };
};
```

```svelte
<!-- src/routes/blog/[slug]/+page.svelte -->
<script lang="ts">
  import type { PageData } from './$types';
  
  let { data }: { data: PageData } = $props();
  // data.post is fully typed!
</script>

<h1>{data.post.title}</h1>
<p>By {data.post.author}</p>
```

> [!TIP]
> Always import types from `./$types`. SvelteKit generates these based on your actual load function returns, so they're always accurate.

### Type Inference

If you don't want to explicitly annotate, SvelteKit infers types:

```typescript
// Types are inferred from the return statement
export async function load({ params }) {
  return {
    title: 'Hello',        // string
    count: 42,             // number
    items: ['a', 'b', 'c'] // string[]
  };
}
```

---

## ğŸ“ Layout Load Functions

Layouts can have their own load functions. Data from layout loads is available to all child pages and layouts.

### File Structure

```
src/routes/
â”œâ”€â”€ +layout.js          â† Root layout load
â”œâ”€â”€ +layout.svelte
â”œâ”€â”€ +page.svelte        â† Has access to layout data
â””â”€â”€ dashboard/
    â”œâ”€â”€ +layout.js      â† Dashboard layout load
    â”œâ”€â”€ +layout.svelte
    â”œâ”€â”€ +page.svelte    â† Has access to BOTH layout data
    â””â”€â”€ settings/
        â””â”€â”€ +page.svelte â† Has access to BOTH layout data
```

### Root Layout Load

```javascript
// src/routes/+layout.server.js
export async function load({ cookies }) {
  const theme = cookies.get('theme') || 'light';
  const user = await getUserFromSession(cookies);
  
  return { theme, user };
}
```

### Child Layout Load

```javascript
// src/routes/dashboard/+layout.server.js
export async function load({ parent }) {
  // Get data from parent layout
  const { user } = await parent();
  
  // Fetch additional data for dashboard
  const notifications = await getNotifications(user.id);
  
  return { notifications };
}
```

### Accessing Layout Data in Pages

```svelte
<!-- src/routes/dashboard/settings/+page.svelte -->
<script>
  let { data } = $props();
  
  // data.theme         - from root layout
  // data.user          - from root layout
  // data.notifications - from dashboard layout
  // data.settings      - from this page's load (if any)
</script>
```

---

## ğŸ”„ Universal vs Server: When to Use Which?

| Scenario | Use |
| :--- | :--- |
| Public API calls | `+page.js` (universal) |
| Database queries | `+page.server.js` |
| Using API keys/secrets | `+page.server.js` |
| Reading cookies | `+page.server.js` |
| Data that can be cached on CDN | `+page.js` |
| User-specific data | `+page.server.js` |

### Both Files Together

You can have **both** `+page.js` and `+page.server.js` for the same route:

```javascript
// +page.server.js - runs first, server only
export async function load({ cookies }) {
  const token = cookies.get('auth');
  return { token };
}

// +page.js - runs on server AND client
export async function load({ data, fetch }) {
  // 'data' contains the return value from +page.server.js
  const { token } = data;
  
  const res = await fetch('/api/user', {
    headers: { Authorization: `Bearer ${token}` }
  });
  
  return { user: await res.json() };
}
```

---

## âš ï¸ Common Pitfalls

### âŒ Pitfall 1: Fetching in Components

```svelte
<!-- DON'T DO THIS -->
<script>
  import { onMount } from 'svelte';
  
  let posts = $state([]);
  
  onMount(async () => {
    const res = await fetch('/api/posts');
    posts = await res.json();
  });
</script>
```

**Problem**: Data isn't available during SSR, harming SEO and causing layout shift.

**Solution**: Use load functions instead.

---

### âŒ Pitfall 2: Importing Server Modules in Universal Load

```javascript
// +page.js - THIS WILL BREAK
import { db } from '$lib/server/database'; // âŒ Server-only module!

export async function load() {
  return { users: await db.user.findMany() };
}
```

**Problem**: `$lib/server` can't be imported in browser code.

**Solution**: Use `+page.server.js` for database access, or create an API endpoint.

---

### âŒ Pitfall 3: Not Awaiting Parent Data

```javascript
// +page.js
export async function load({ parent }) {
  const parentData = parent(); // âŒ Missing await!
  console.log(parentData.user); // undefined
}
```

**Solution**: Always `await parent()`.

---

## âœ… Best Practices

### 1. Keep Load Functions Focused

```javascript
// âœ… Good: Single responsibility
export async function load({ params }) {
  const post = await fetchPost(params.slug);
  return { post };
}

// âŒ Bad: Too much logic
export async function load({ params, cookies, url }) {
  const post = await fetchPost(params.slug);
  const user = await getUser(cookies);
  const related = await fetchRelated(post.id);
  const comments = await fetchComments(post.id);
  const analytics = await trackView(post.id, user?.id);
  // ... too much!
}
```

### 2. Use Parallel Fetching When Possible

```javascript
// âœ… Parallel - faster!
export async function load({ params }) {
  const [post, comments] = await Promise.all([
    fetchPost(params.slug),
    fetchComments(params.slug)
  ]);
  
  return { post, comments };
}

// âŒ Sequential - slower
export async function load({ params }) {
  const post = await fetchPost(params.slug);
  const comments = await fetchComments(params.slug);
  return { post, comments };
}
```

### 3. Handle Errors Gracefully

```javascript
import { error } from '@sveltejs/kit';

export async function load({ params }) {
  const post = await fetchPost(params.slug);
  
  if (!post) {
    throw error(404, {
      message: 'Post not found',
      code: 'POST_NOT_FOUND'
    });
  }
  
  return { post };
}
```

---

## ğŸ“Š Summary

| Concept | Key Point |
| :--- | :--- |
| **Universal Load** | Runs on server + client, use for public API calls |
| **Server Load** | Runs only on server, use for DB/secrets/cookies |
| **Generated Types** | Import from `./$types` for automatic type safety |
| **Layout Load** | Data flows down to all child routes |
| **`await parent()`** | Access parent layout data in child loads |

---

**Next Up**: [Advanced Load Patterns](./02.%20Advanced%20Load%20Patterns.md) â†’
