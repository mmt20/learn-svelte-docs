# 02. Advanced Load Patterns

This document covers advanced data loading patterns in SvelteKit, including parent data access, streaming, parallel requests, and passing components from load functions.

---

## üîó Accessing Parent Data in Child Load Functions

Child load functions can access data from parent layouts using `await parent()`.

### Basic Usage

```javascript
// src/routes/+layout.server.js
export async function load({ cookies }) {
  const user = await getUserFromSession(cookies);
  return { user };
}
```

```javascript
// src/routes/dashboard/+page.server.js
export async function load({ parent }) {
  // Wait for parent layout data
  const { user } = await parent();
  
  // Use parent data to fetch more
  const dashboard = await getDashboardData(user.id);
  
  return { dashboard };
}
```

### Multiple Parent Levels

Data accumulates through the layout hierarchy:

```javascript
// src/routes/+layout.js ‚Üí { user }
// src/routes/dashboard/+layout.js ‚Üí { notifications }
// src/routes/dashboard/settings/+page.js

export async function load({ parent }) {
  const { user, notifications } = await parent();
  // Both are available!
  
  return { 
    settings: await getSettings(user.id),
    unreadCount: notifications.filter(n => !n.read).length
  };
}
```

> [!WARNING]
> Calling `parent()` creates a **waterfall**. The child load waits for all parent loads to complete. Only use `parent()` when you actually need the parent data.

### Avoiding Unnecessary Waterfalls

```javascript
// ‚ùå BAD: Creates waterfall even though we don't need parent data
export async function load({ parent, params, fetch }) {
  await parent(); // Unnecessary wait!
  const res = await fetch(`https://dummyjson.com/posts/${params.slug}`);
  return { post: await res.json() };
}

// ‚úÖ GOOD: No waterfall, runs in parallel with parent
export async function load({ params, fetch }) {
  const res = await fetch(`https://dummyjson.com/posts/${params.slug}`);
  return { post: await res.json() };
}
```

---

## üì§ Passing Data From Pages to Layouts

Sometimes you need to send data **up** from a page to its layout (e.g., page title, breadcrumbs).

### Using `$page.data` in Layouts

All data from the page's load function is available in `$page.data`:

```javascript
// src/routes/blog/[id]/+page.js
export async function load({ params, fetch }) {
  const res = await fetch(`https://dummyjson.com/posts/${params.id}`);
  const post = await res.json();
  
  return { 
    post,
    title: post.title,        // For the layout
    breadcrumbs: [
      { label: 'Blog', href: '/blog' },
      { label: post.title, href: `/blog/${post.id}` }
    ]
  };
}
```

```svelte
<!-- src/routes/+layout.svelte -->
<script>
  import { page } from '$app/state';
  
  let { children } = $props();
</script>

<svelte:head>
  <title>{page.data.title ?? 'My Site'}</title>
</svelte:head>

{#if page.data.breadcrumbs}
  <nav class="breadcrumbs">
    {#each page.data.breadcrumbs as crumb}
      <a href={crumb.href}>{crumb.label}</a>
    {/each}
  </nav>
{/if}

{@render children()}
```

> [!TIP]
> Use optional chaining (`page.data.title ?? 'Default'`) since not all pages may provide the data.

---

## üß© Passing Svelte Components From Load Functions

You can return Svelte components from load functions for dynamic rendering.

### Use Case: Dynamic Widgets

```javascript
// src/routes/dashboard/+page.js
import StatsWidget from '$lib/widgets/StatsWidget.svelte';
import ChartWidget from '$lib/widgets/ChartWidget.svelte';

export async function load({ fetch }) {
  const config = await fetch('/api/dashboard-config').then(r => r.json());
  
  const widgets = config.widgets.map(w => {
    switch (w.type) {
      case 'stats': return { component: StatsWidget, props: w.data };
      case 'chart': return { component: ChartWidget, props: w.data };
    }
  });
  
  return { widgets };
}
```

```svelte
<!-- src/routes/dashboard/+page.svelte -->
<script>
  let { data } = $props();
</script>

<div class="dashboard-grid">
  {#each data.widgets as widget}
    <widget.component {...widget.props} />
  {/each}
</div>
```

> [!IMPORTANT]
> Components can only be returned from **universal** load functions (`+page.js`), not server load functions (`+page.server.js`). Components aren't serializable.

---

## ‚ö° Running Requests in Parallel with `Promise.all`

Sequential requests create waterfalls. Use `Promise.all` to run independent requests in parallel.

### Sequential (Slow) ‚ùå

```javascript
export async function load({ params, fetch }) {
  // Fetch post (wait...)
  const postRes = await fetch(`https://dummyjson.com/posts/${params.id}`);
  const post = await postRes.json();
  
  // THEN fetch comments (wait...)
  const commentsRes = await fetch(`https://dummyjson.com/posts/${params.id}/comments`);
  const comments = await commentsRes.json();
  
  // THEN fetch user (wait...)
  const userRes = await fetch(`https://dummyjson.com/users/${post.userId}`);
  const author = await userRes.json();
  
  return { post, comments, author };
}
```

### Parallel (Fast) ‚úÖ

```javascript
export async function load({ params, fetch }) {
  // Start independent requests simultaneously
  const [postRes, commentsRes] = await Promise.all([
    fetch(`https://dummyjson.com/posts/${params.id}`),
    fetch(`https://dummyjson.com/posts/${params.id}/comments`)
  ]);
  
  const post = await postRes.json();
  const commentsData = await commentsRes.json();
  
  // Dependent request: must wait for post to get userId
  const authorRes = await fetch(`https://dummyjson.com/users/${post.userId}`);
  const author = await authorRes.json();
  
  return { 
    post, 
    comments: commentsData.comments, 
    author 
  };
}
```

### Handling Partial Failures

```javascript
export async function load({ params, fetch }) {
  const results = await Promise.allSettled([
    fetch(`https://dummyjson.com/posts/${params.id}`),
    fetch(`https://dummyjson.com/posts/${params.id}/comments`),
    fetch(`https://dummyjson.com/quotes/random`) // Extra content
  ]);
  
  const [postResult, commentsResult, quoteResult] = results;
  
  // Post is required - throw if failed
  if (postResult.status === 'rejected' || !postResult.value.ok) {
    throw error(404, 'Post not found');
  }
  
  return {
    post: await postResult.value.json(),
    // Optional data - handle failure gracefully
    comments: commentsResult.status === 'fulfilled' && commentsResult.value.ok 
      ? (await commentsResult.value.json()).comments 
      : [],
    quote: quoteResult.status === 'fulfilled' && quoteResult.value.ok
      ? await quoteResult.value.json()
      : null
  };
}
```

---

## üåä Streaming Data From Server Load Functions

SvelteKit can **stream** data to the client. Return a promise (don't await it) to start rendering immediately while data loads in the background.

### How Streaming Works

1. Server returns immediately with available data (awaited promises)
2. Unresolved promises are sent as placeholders
3. When promises resolve, data streams to the client
4. Svelte automatically updates the UI

### Implementing Streaming

```javascript
// src/routes/dashboard/+page.server.js
export async function load({ fetch }) {
  // 1. Critical data (await this)
  const user = await fetch('https://dummyjson.com/users/1')
    .then(r => r.json());
    
  // 2. Slow/Secondary data (return the Promise)
  const statsPromise = fetch('https://dummyjson.com/users?limit=5&select=firstName,age')
    .then(r => r.json());
    
  const activityPromise = fetch('https://dummyjson.com/posts?limit=5')
    .then(r => r.json());

  return {
    user,
    // Streamed promises
    stats: statsPromise,
    recentActivity: activityPromise
  };
}
```

```svelte
<!-- src/routes/dashboard/+page.svelte -->
<script>
  let { data } = $props();
</script>

<h1>Welcome back, {data.user.firstName}!</h1>

<div class="dashboard">
  <!-- Section 1: User Stats (Streams in) -->
  <section>
    <h2>Community Stats</h2>
    {#await data.stats}
      <p class="loading">Loading stats...</p>
    {:then stats}
      <ul>
        {#each stats.users as user}
          <li>{user.firstName} ({user.age})</li>
        {/each}
      </ul>
    {:catch error}
      <p class="error">Could not load stats</p>
    {/await}
  </section>

  <!-- Section 2: Recent Activity (Streams in) -->
  <section>
    <h2>Recent Posts</h2>
    {#await data.recentActivity}
      <div class="skeleton-list">
        <div></div><div></div><div></div>
      </div>
    {:then activity}
      <ul>
        {#each activity.posts as post}
          <li>{post.title}</li>
        {/each}
      </ul>
    {/await}
  </section>
</div>
```

### Benefits of Streaming

| Benefit | Description |
| :--- | :--- |
| **Faster TTFB** | Server responds immediately with partial HTML |
| **Progressive Loading** | Users see content as it becomes available |
| **Better Perceived Performance** | No blank screen while waiting for slow data |
| **Graceful Degradation** | Critical data loads first, optional data streams |

> [!IMPORTANT]
> Streaming only works with **server** load functions (`+page.server.js`). Universal loads must await all data before the component can render.

---

## üîÑ Invalidation and Re-running Loads

### Manual Invalidation

```javascript
// src/routes/posts/+page.js
export async function load({ fetch, depends }) {
  // Register a custom dependency
  depends('app:posts');
  
  const posts = await fetch('https://dummyjson.com/posts').then(r => r.json());
  return { posts: posts.posts };
}
```

```svelte
<!-- Somewhere in your app -->
<script>
  import { invalidate, invalidateAll } from '$app/navigation';
  
  async function refresh() {
    // Invalidate specific dependency to re-run the load
    await invalidate('app:posts');
    
    // Or invalidate everything
    await invalidateAll();
  }
</script>

<button onclick={refresh}>Refresh Posts</button>
```

---

## ‚ö†Ô∏è Common Pitfalls

### ‚ùå Pitfall 1: Awaiting Streamed Data Unnecessarily

```javascript
// ‚ùå BAD: Defeats streaming because we await everything
export async function load({ fetch }) {
  const stats = await fetch('https://dummyjson.com/users').then(r => r.json());
  return { stats };
}

// ‚úÖ GOOD: Enables streaming by returning the promise
export async function load({ fetch }) {
  return { 
    stats: fetch('https://dummyjson.com/users').then(r => r.json()) 
  }; 
}
```

---

### ‚ùå Pitfall 2: Sequential Parent Calls

```javascript
// ‚ùå BAD: Calls parent() multiple times
export async function load({ parent }) {
  const p1 = await parent();
  const data1 = await fetchData(p1.user.id);
  
  const p2 = await parent(); // Redundant!
  const data2 = await fetchMore(p2.user.id);
}

// ‚úÖ GOOD: Call parent() once
export async function load({ parent }) {
  const { user } = await parent();
  
  const [data1, data2] = await Promise.all([
    fetchData(user.id),
    fetchMore(user.id)
  ]);
  
  return { data1, data2 };
}
```

---

## ‚úÖ Best Practices

### 1. Structure Data for Streaming

```javascript
// Structure your returns for optimal streaming
export async function load({ fetch }) {
  return {
    // Critical data - await it
    config: await fetch('/api/config').then(r => r.json()),
    
    // Slow data - stream it
    heavyData: fetch('/api/heavy-calculation').then(r => r.json())
  };
}
```

### 2. Use `depends()` for Custom Invalidation

```javascript
export async function load({ depends }) {
  depends('app:user-preferences');
  
  // Now you can invalidate('app:user-preferences')
  // to re-run this load without affecting others
}
```

---

## üìä Summary

| Pattern | When to Use |
| :--- | :--- |
| **`await parent()`** | Need data from parent layout |
| **`$page.data`** | Pass page data up to layouts |
| **`Promise.all`** | Multiple independent requests |
| **Streaming** | Large/slow data that isn't immediately needed |
| **`depends()`** | Custom cache invalidation |

---

**Next Up**: [Endpoints and API Routes](./03.%20Endpoints%20and%20API%20Routes.md) ‚Üí
