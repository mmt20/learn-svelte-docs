# 04. Navigation Hooks and Loading UI

This document covers SvelteKit's navigation lifecycle hooks and how to build loading indicators, progress bars, and handle navigation events.

---

## ðŸŽ¯ Navigation Lifecycle Overview

SvelteKit provides hooks to intercept and respond to navigation events:

| Hook | When It Fires | Use Case |
| :--- | :--- | :--- |
| `beforeNavigate` | Before navigation starts | Confirm unsaved changes, cancel navigation |
| `onNavigate` | During navigation (client-side) | View transitions, prepare animations |
| `afterNavigate` | After navigation completes | Analytics, scroll restoration, cleanup |

---

## ðŸš¦ `beforeNavigate` - Intercepting Navigation

`beforeNavigate` runs before a navigation starts. You can cancel it or show confirmation dialogs.

### Basic Usage

```svelte
<script>
  import { beforeNavigate } from '$app/navigation';
  
  beforeNavigate((navigation) => {
    console.log('Navigating from:', navigation.from?.url.pathname);
    console.log('Navigating to:', navigation.to?.url.pathname);
    console.log('Navigation type:', navigation.type);
  });
</script>
```

### Navigation Object Properties

| Property | Type | Description |
| :--- | :--- | :--- |
| `from` | `{ url, params, route }` | Current page info (null on initial load) |
| `to` | `{ url, params, route }` | Destination page info (null if external) |
| `type` | `'link' \| 'popstate' \| 'goto'` | What triggered the navigation |
| `willUnload` | `boolean` | True if leaving the SvelteKit app |
| `cancel()` | `function` | Prevents the navigation |

### Confirming Unsaved Changes

```svelte
<script>
  import { beforeNavigate } from '$app/navigation';
  
  let hasUnsavedChanges = $state(false);
  let formData = $state({ title: '', content: '' });
  
  // Track changes
  $effect(() => {
    hasUnsavedChanges = formData.title !== '' || formData.content !== '';
  });
  
  beforeNavigate((navigation) => {
    if (hasUnsavedChanges && !navigation.willUnload) {
      if (!confirm('You have unsaved changes. Leave anyway?')) {
        navigation.cancel();
      }
    }
  });
</script>

<form>
  <input bind:value={formData.title} placeholder="Title" />
  <textarea bind:value={formData.content} placeholder="Content"></textarea>
  <button type="submit">Save</button>
</form>
```

### Handling External Navigation

```svelte
<script>
  import { beforeNavigate } from '$app/navigation';
  
  beforeNavigate((navigation) => {
    if (navigation.willUnload) {
      // User is leaving the SvelteKit app entirely
      // Use the native beforeunload event instead
      return;
    }
    
    // Internal navigation - we can cancel this
    if (shouldPreventNavigation()) {
      navigation.cancel();
    }
  });
</script>
```

> [!IMPORTANT]
> `navigation.cancel()` only works for client-side navigation. For full page reloads or external links, use the browser's `beforeunload` event.

---

## ðŸŽ¬ `onNavigate` - View Transitions

`onNavigate` runs during navigation and is ideal for implementing view transitions.

### Basic Usage

```svelte
<script>
  import { onNavigate } from '$app/navigation';
  
  onNavigate((navigation) => {
    // Return a promise to delay navigation completion
    return new Promise((resolve) => {
      // Do something, then resolve
      setTimeout(resolve, 100);
    });
  });
</script>
```

### View Transitions API

```svelte
<script>
  import { onNavigate } from '$app/navigation';
  
  onNavigate((navigation) => {
    // Check browser support
    if (!document.startViewTransition) return;
    
    return new Promise((resolve) => {
      document.startViewTransition(async () => {
        resolve();
        await navigation.complete;
      });
    });
  });
</script>

<style>
  /* View transition animations */
  @keyframes fade-in {
    from { opacity: 0; }
  }
  
  @keyframes fade-out {
    to { opacity: 0; }
  }
  
  @keyframes slide-from-right {
    from { transform: translateX(30px); }
  }
  
  @keyframes slide-to-left {
    to { transform: translateX(-30px); }
  }
  
  :root::view-transition-old(root) {
    animation: 90ms cubic-bezier(0.4, 0, 1, 1) both fade-out,
               300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-to-left;
  }
  
  :root::view-transition-new(root) {
    animation: 210ms cubic-bezier(0, 0, 0.2, 1) 90ms both fade-in,
               300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-from-right;
  }
</style>
```

---

## âœ… `afterNavigate` - Post-Navigation Actions

`afterNavigate` runs after navigation completes. Use it for analytics, scroll management, or cleanup.

### Basic Usage

```svelte
<script>
  import { afterNavigate } from '$app/navigation';
  
  afterNavigate((navigation) => {
    console.log('Navigation complete!');
    console.log('Previous page:', navigation.from?.url.pathname);
    console.log('Current page:', navigation.to?.url.pathname);
    console.log('Type:', navigation.type);
  });
</script>
```

### Analytics Tracking

```svelte
<script>
  import { afterNavigate } from '$app/navigation';
  import { browser } from '$app/environment';
  
  afterNavigate((navigation) => {
    if (browser && navigation.to) {
      // Google Analytics 4
      gtag('event', 'page_view', {
        page_path: navigation.to.url.pathname,
        page_title: document.title
      });
      
      // Or custom analytics
      fetch('/api/analytics', {
        method: 'POST',
        body: JSON.stringify({
          path: navigation.to.url.pathname,
          referrer: navigation.from?.url.pathname
        })
      });
    }
  });
</script>

{@render children()}
```

### Scroll to Top

```svelte
<script>
  import { afterNavigate } from '$app/navigation';
  
  afterNavigate((navigation) => {
    // Don't scroll on back/forward navigation
    if (navigation.type !== 'popstate') {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  });
</script>
```

### Focus Management (Accessibility)

```svelte
<script>
  import { afterNavigate } from '$app/navigation';
  
  let mainContent;
  
  afterNavigate(() => {
    // Focus the main content for screen readers
    mainContent?.focus();
  });
</script>

<main bind:this={mainContent} tabindex="-1">
  {@render children()}
</main>
```

---

## ðŸ“Š Building a Loading Progress Bar

A progress bar provides visual feedback during navigation.

### Complete Implementation

```svelte
<!-- src/lib/components/NavigationProgress.svelte -->
<script>
  import { navigating } from '$app/state';
  
  let progress = $state(0);
  let visible = $state(false);
  let intervalId;
  
  $effect(() => {
    if (navigating.to) {
      // Navigation started
      visible = true;
      progress = 0;
      
      // Simulate progress
      intervalId = setInterval(() => {
        // Slow down as we approach 90%
        if (progress < 90) {
          progress += (90 - progress) * 0.1;
        }
      }, 100);
    } else {
      // Navigation ended
      if (visible) {
        progress = 100;
        
        // Hide after animation
        setTimeout(() => {
          visible = false;
          progress = 0;
        }, 300);
      }
      
      clearInterval(intervalId);
    }
    
    return () => clearInterval(intervalId);
  });
</script>

{#if visible}
  <div class="progress-bar" style="width: {progress}%"></div>
{/if}

<style>
  .progress-bar {
    position: fixed;
    top: 0;
    left: 0;
    height: 3px;
    background: linear-gradient(90deg, #3b82f6, #8b5cf6);
    z-index: 9999;
    transition: width 0.1s ease-out;
    box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
  }
</style>
```

### Usage in Layout

```svelte
<!-- src/routes/+layout.svelte -->
<script>
  import NavigationProgress from '$lib/components/NavigationProgress.svelte';
  
  let { children } = $props();
</script>

<NavigationProgress />

<header>
  <!-- Navigation -->
</header>

<main>
  {@render children()}
</main>
```

### Alternative: NProgress-Style

```svelte
<script>
  import { navigating } from '$app/state';
  
  let progress = $state(0);
  let visible = $state(false);
  let trickleInterval;
  
  function startTrickle() {
    trickleInterval = setInterval(() => {
      if (progress < 99) {
        // Random increment, slowing as we progress
        const increment = (1 - progress / 100) * (Math.random() * 2 + 0.5);
        progress = Math.min(99, progress + increment);
      }
    }, 200);
  }
  
  function stop() {
    clearInterval(trickleInterval);
    progress = 100;
    setTimeout(() => {
      visible = false;
      progress = 0;
    }, 400);
  }
  
  $effect(() => {
    if (navigating.to && !visible) {
      visible = true;
      progress = 0;
      // Small delay before starting
      setTimeout(() => {
        progress = 10;
        startTrickle();
      }, 50);
    } else if (!navigating.to && visible) {
      stop();
    }
    
    return () => clearInterval(trickleInterval);
  });
</script>

<div class="nprogress" class:visible>
  <div class="bar" style="transform: translateX({progress - 100}%)">
    <div class="peg"></div>
  </div>
</div>

<style>
  .nprogress {
    pointer-events: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.2s;
  }
  
  .nprogress.visible {
    opacity: 1;
  }
  
  .bar {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #29d;
    transition: transform 0.2s ease;
  }
  
  .peg {
    position: absolute;
    right: 0;
    width: 100px;
    height: 100%;
    box-shadow: 0 0 10px #29d, 0 0 5px #29d;
    transform: rotate(3deg) translateY(-4px);
  }
</style>
```

---

## ðŸ”„ Using `navigating` Store

The `navigating` store provides reactive access to navigation state.

### Disabling UI During Navigation

```svelte
<script>
  import { navigating } from '$app/state';
</script>

<nav>
  <a href="/" class:disabled={navigating.to}>Home</a>
  <a href="/about" class:disabled={navigating.to}>About</a>
  <a href="/contact" class:disabled={navigating.to}>Contact</a>
</nav>

{#if navigating.to}
  <div class="loading-overlay">
    <span class="spinner"></span>
  </div>
{/if}

<style>
  .disabled {
    pointer-events: none;
    opacity: 0.5;
  }
  
  .loading-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
  }
</style>
```

### Showing Loading State Per-Route

```svelte
<script>
  import { navigating } from '$app/state';
  
  let loadingPath = $derived(navigating.to?.url.pathname);
</script>

<nav>
  <a href="/dashboard">
    Dashboard
    {#if loadingPath === '/dashboard'}
      <span class="loading-indicator">...</span>
    {/if}
  </a>
  <a href="/settings">
    Settings
    {#if loadingPath === '/settings'}
      <span class="loading-indicator">...</span>
    {/if}
  </a>
</nav>
```

---

## âš ï¸ Common Pitfalls

### âŒ Pitfall 1: Blocking Navigation Too Long

```javascript
// âŒ BAD: Blocks navigation for 5 seconds
onNavigate(() => {
  return new Promise(resolve => setTimeout(resolve, 5000));
});

// âœ… GOOD: Keep transitions short
onNavigate(() => {
  return new Promise(resolve => setTimeout(resolve, 300));
});
```

---

### âŒ Pitfall 2: Not Cleaning Up Intervals

```javascript
// âŒ BAD: Interval keeps running
$effect(() => {
  if (navigating.to) {
    setInterval(() => progress++, 100); // Leaks!
  }
});

// âœ… GOOD: Clean up in effect
$effect(() => {
  if (navigating.to) {
    const id = setInterval(() => progress++, 100);
    return () => clearInterval(id);
  }
});
```

---

### âŒ Pitfall 3: Forgetting `willUnload`

```javascript
// âŒ BAD: cancel() won't work for external links
beforeNavigate(({ cancel }) => {
  if (hasUnsavedChanges) {
    cancel(); // Only works for internal navigation!
  }
});

// âœ… GOOD: Check willUnload
beforeNavigate(({ cancel, willUnload }) => {
  if (hasUnsavedChanges && !willUnload) {
    if (!confirm('Leave?')) cancel();
  }
});

// Also handle full page unloads
window.addEventListener('beforeunload', (e) => {
  if (hasUnsavedChanges) {
    e.preventDefault();
    e.returnValue = '';
  }
});
```

---

## âœ… Best Practices

### 1. Keep Progress Bars Fast

```javascript
// Start at 10-20% immediately for perceived speed
progress = 15;
```

### 2. Use Preloading to Reduce Wait Time

```svelte
<!-- Preload on hover/focus -->
<a href="/dashboard" data-sveltekit-preload-data="hover">
  Dashboard
</a>
```

### 3. Provide Multiple Loading Indicators

```svelte
<!-- Global progress bar for overall navigation -->
<NavigationProgress />

<!-- Local skeleton for content area -->
{#if navigating.to?.url.pathname.startsWith('/blog')}
  <BlogSkeleton />
{/if}
```

### 4. Handle Slow Networks

```svelte
<script>
  import { navigating } from '$app/state';
  
  let slowNetwork = $state(false);
  let timeout;
  
  $effect(() => {
    if (navigating.to) {
      // Show "slow network" after 3 seconds
      timeout = setTimeout(() => {
        slowNetwork = true;
      }, 3000);
    } else {
      slowNetwork = false;
      clearTimeout(timeout);
    }
    return () => clearTimeout(timeout);
  });
</script>

{#if slowNetwork}
  <div class="slow-warning">
    Taking longer than usual...
  </div>
{/if}
```

---

## ðŸ“Š Summary

| Hook/Store | Purpose |
| :--- | :--- |
| `beforeNavigate` | Intercept/cancel navigation, confirm unsaved changes |
| `onNavigate` | View transitions, animation setup |
| `afterNavigate` | Analytics, accessibility focus, cleanup |
| `navigating` | Reactive navigation state for loading UI |

